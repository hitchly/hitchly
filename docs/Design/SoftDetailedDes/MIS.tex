\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} & Input Parameters\\
& Output Format\\
& Output Verification\\
& Temperature ODEs\\
& Energy Equations\\ 
& Control Module\\
& Specification Parameters Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}\\
& ODE Solver\\
& Plotting\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS for Modules}

\subsection{6.1 Authentication \& Verification Module}

\subsubsection{6.1.1 Module}
The Authentication \& Verification Module manages user identity creation, secure login, and McMaster email verification for all Hitchly users.
This module is implemented using the \textbf{BetterAuth} authentication framework, which provides end-to-end session management, credential validation, and token-based verification. 
It ensures that only users with verified \texttt{@mcmaster.ca} emails can access the system’s features.

\paragraph{6.1.1.1 Frontend}
The frontend component is integrated into the Expo mobile application.  
It provides the UI flow for login, signup, and verification.  
User input is collected through secure forms and sent to the backend via tRPC.  
The frontend handles the following:
\begin{itemize}
    \item Displays login and signup screens.
    \item Manages form validation and field state.
    \item Invokes BetterAuth client hooks for authentication (e.g., \texttt{useSignIn()}, \texttt{useSignUp()}).
    \item Handles redirect and session persistence after successful login.
    \item Presents error messages for invalid credentials or unverified accounts.
\end{itemize}

\paragraph{6.1.1.2 Backend}
The backend is implemented in the Express/tRPC API using \textbf{BetterAuth’s server SDK}.  
It manages credential validation, session tokens, McMaster domain enforcement, and email verification logic.
Key backend operations include:
\begin{itemize}
    \item Configuring BetterAuth provider for the Hitchly API.
    \item Enforcing allowed email domains (\texttt{@mcmaster.ca}) during registration.
    \item Generating and validating secure verification tokens.
    \item Managing persistent user sessions through signed cookies and JWTs.
    \item Integrating with the email service for verification links.
\end{itemize}

\paragraph{6.1.1.3 Data}
The data layer persists authentication and verification information within the PostgreSQL database managed by Drizzle ORM.
BetterAuth automatically provisions and maintains required tables:
\begin{itemize}
    \item \texttt{users} — stores user credentials, roles, and verification state.
    \item \texttt{sessions} — stores active user sessions with expiry timestamps.
    \item \texttt{verification\_tokens} — tracks issued and redeemed email verification tokens.
\end{itemize}
Data integrity is enforced by unique constraints on email and by transactional updates during verification.

\subsubsection{6.1.2 Uses}
This module ensures secure access to Hitchly by verifying each user’s McMaster University affiliation.  
It interacts directly with:
\begin{itemize}
    \item \textbf{Frontend UI:} collects credentials and displays verification flows.
    \item \textbf{API Layer:} provides endpoints for signup, login, logout, and verification.
    \item \textbf{Database:} persists user and session data managed through BetterAuth.
\end{itemize}
All other modules depend on this component to validate user identity before allowing access to trip creation, matching, and messaging features.

\subsubsection{6.1.3 Syntax}

\paragraph{6.1.3.1 Exported Constants}
\begin{itemize}
    \item \texttt{ALLOWED\_DOMAIN = "@mcmaster.ca"}  
    Restricts signup to McMaster-affiliated emails.
    \item \texttt{SESSION\_EXPIRY = 24h}  
    Sets the maximum lifetime for user sessions.
\end{itemize}

\paragraph{6.1.3.2 Exported Access Programs}
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{registerUser()} & name, email, password & verificationToken & DuplicateEmailError \\
\texttt{loginUser()} & email, password & sessionToken & InvalidCredentialsError \\
\texttt{verifyEmail()} & verificationToken & successFlag & ExpiredTokenError \\
\texttt{logoutUser()} & sessionToken & confirmation & InvalidSessionError \\
\bottomrule
\end{tabular}

\subsubsection{6.1.4 Semantics}

\paragraph{6.1.4.1 State Variables}
\begin{itemize}
    \item \texttt{isVerified: bool} — indicates whether the user’s email has been confirmed.
    \item \texttt{authToken: string} — stores the active session token generated by BetterAuth.
    \item \texttt{sessionState: object} — holds session metadata for frontend persistence.
\end{itemize}

\paragraph{6.1.4.2 Environment Variables}
\begin{itemize}
    \item User device input (keyboard, network, mobile UI).
    \item Secure HTTPS connection to API.
    \item Email server or transactional service for verification emails.
\end{itemize}

\paragraph{6.1.4.3 Assumptions}
\begin{itemize}
    \item All users have valid McMaster email accounts.
    \item Database migrations and BetterAuth setup scripts have been executed.
    \item Network connectivity is stable during registration or verification.
\end{itemize}

\paragraph{6.1.4.4 Access Routine Semantics}

\texttt{registerUser()}:
\begin{itemize}
    \item \textbf{transition:} Inserts a new pending user into the database and triggers a verification email.
    \item \textbf{output:} Returns a token or link for verification.
    \item \textbf{exception:} Thrown if email already exists or invalid domain detected.
\end{itemize}

\texttt{loginUser()}:
\begin{itemize}
    \item \textbf{transition:} Validates credentials and creates a session.
    \item \textbf{output:} Returns a signed JWT or session cookie.
    \item \textbf{exception:} InvalidCredentialsError if authentication fails.
\end{itemize}

\texttt{verifyEmail()}:
\begin{itemize}
    \item \textbf{transition:} Updates user’s \texttt{isVerified} state to true.
    \item \textbf{output:} Returns success confirmation.
    \item \textbf{exception:} ExpiredTokenError if verification link invalid or expired.
\end{itemize}

\texttt{logoutUser()}:
\begin{itemize}
    \item \textbf{transition:} Revokes session in \texttt{sessions} table.
    \item \textbf{output:} Confirmation of logout.
    \item \textbf{exception:} InvalidSessionError if session token not found.
\end{itemize}

\paragraph{6.1.4.5 Local Functions}
\begin{itemize}
    \item \texttt{generateVerificationToken(): string} — Creates a cryptographically secure token.
    \item \texttt{validateEmailDomain(email: string): boolean} — Ensures domain ends with \texttt{@mcmaster.ca}.
    \item \texttt{hashPassword(password: string): string} — Applies secure hashing for stored credentials.
\end{itemize}

\subsection{6.2 User Profile Module}

\subsubsection{6.2.1 Module}
The User Profile Module manages all personal and contextual information about a Hitchly user.  
It allows students, alumni, and faculty to view and edit their personal data, preferences, and role (rider, driver, or both).  
This module integrates directly with the Authentication \& Verification Module for identity linkage and with the Matching Module to supply accurate data for matchmaking.

\paragraph{6.2.1.1 Frontend}
The frontend portion resides in the Expo mobile application.  
It provides interfaces for profile creation, editing, and display, implemented using shared UI components.  
Key features include:
\begin{itemize}
    \item Editable profile screen showing name, faculty, year, and role.
    \item Driver-specific section for vehicle information (make, model, seats).
    \item Preference selection for quiet/chatty rides, music, and other comfort options.
    \item Integration with camera/gallery for optional profile photo upload.
    \item Form validation and error messaging for incomplete or invalid fields.
    \item Communication with backend via tRPC hooks (e.g., \texttt{useGetUser()}, \texttt{useUpdateUser()}).
\end{itemize}

\paragraph{6.2.1.2 Backend}
The backend implements the business logic and data orchestration using Express and tRPC.  
It exposes endpoints for retrieving, updating, and deleting user data.  
Main responsibilities include:
\begin{itemize}
    \item Providing tRPC procedures such as \texttt{getUserProfile}, \texttt{updateUserProfile}, and \texttt{deleteUser}.
    \item Validating incoming payloads using Zod schemas for type safety.
    \item Enforcing access control through session validation from BetterAuth.
    \item Maintaining referential integrity with linked tables (e.g., trips, ratings).
    \item Broadcasting profile updates to dependent modules (e.g., Matching, Analytics).
\end{itemize}

\paragraph{6.2.1.3 Data}
The data layer defines persistent entities stored in PostgreSQL via Drizzle ORM.  
Key tables include:
\begin{itemize}
    \item \texttt{users} — stores user metadata such as name, role, faculty, and profile image URL.
    \item \texttt{vehicles} — stores driver vehicle details and capacity.
    \item \texttt{preferences} — stores personal ride preferences and settings.
\end{itemize}
All tables use foreign-key constraints to maintain one-to-one or one-to-many relationships with user records.  
Schema migrations ensure consistent structure across environments.

\subsubsection{6.2.2 Uses}
This module is used to manage user data required across the entire Hitchly system.  
It interacts with:
\begin{itemize}
    \item \textbf{Authentication \& Verification Module} – links verified user identity to profile records.
    \item \textbf{Matching Module} – provides profile and preference data for scoring algorithms.
    \item \textbf{Trip Management Module} – associates user profiles with created or joined trips.
    \item \textbf{Rating \& Feedback Module} – aggregates ride feedback to display reliability metrics.
\end{itemize}
Through these integrations, the module forms the foundation of personalization and trust within Hitchly.

\subsubsection{6.2.3 Syntax}

\paragraph{6.2.3.1 Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_BIO\_LENGTH = 250} – Limits user biography text.
    \item \texttt{DEFAULT\_ROLE = "rider"} – Assigned when a user first registers.
\end{itemize}

\paragraph{6.2.3.2 Exported Access Programs}
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{getUserProfile()} & userId & UserRecord & NotFoundError \\
\texttt{updateUserProfile()} & userId, ProfileData & UpdatedRecord & ValidationError \\
\texttt{deleteUser()} & userId & Confirmation & UnauthorizedError \\
\texttt{getUserPreferences()} & userId & PreferenceData & NotFoundError \\
\texttt{updatePreferences()} & userId, PreferenceData & UpdatedPreference & ValidationError \\
\bottomrule
\end{tabular}

\subsubsection{6.2.4 Semantics}

\paragraph{6.2.4.1 State Variables}
\begin{itemize}
    \item \texttt{userProfile} – Stores the current user information in application state.
    \item \texttt{preferences} – Represents the user’s ride comfort and behavior choices.
    \item \texttt{vehicleData} – Contains driver-specific car details for eligible users.
\end{itemize}

\paragraph{6.2.4.2 Environment Variables}
\begin{itemize}
    \item Mobile UI components and device storage for temporary profile caching.
    \item Active API connection through HTTPS/tRPC.
    \item Database connection via Drizzle ORM.
\end{itemize}

\paragraph{6.2.4.3 Assumptions}
\begin{itemize}
    \item The user is authenticated and verified before modifying profile data.
    \item The database schema has been migrated to include required tables.
    \item Frontend validation is performed prior to API submission.
\end{itemize}

\paragraph{6.2.4.4 Access Routine Semantics}

\texttt{getUserProfile()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns the user’s profile record.
    \item \textbf{exception:} NotFoundError if record absent.
\end{itemize}

\texttt{updateUserProfile()}:
\begin{itemize}
    \item \textbf{transition:} Updates profile fields in database.
    \item \textbf{output:} Returns updated record.
    \item \textbf{exception:} ValidationError for invalid input or missing fields.
\end{itemize}

\texttt{updatePreferences()}:
\begin{itemize}
    \item \textbf{transition:} Rewrites preference entries linked to user ID.
    \item \textbf{output:} Confirmation of successful update.
    \item \textbf{exception:} ValidationError on schema violation.
\end{itemize}

\texttt{deleteUser()}:
\begin{itemize}
    \item \textbf{transition:} Removes user and related data (soft delete or cascade).
    \item \textbf{output:} Success confirmation.
    \item \textbf{exception:} UnauthorizedError if requester lacks privilege.
\end{itemize}

\paragraph{6.2.4.5 Local Functions}
\begin{itemize}
    \item \texttt{sanitizeProfileInput(data)} – Removes disallowed fields and formats strings.
    \item \texttt{mergePreferenceDefaults(prefs)} – Applies default values for missing preference options.
    \item \texttt{calculateReliabilityScore(userId)} – Computes user trust metric from ratings and trip history.
\end{itemize}

\subsection{6.3 Route \& Trip Module}

\subsubsection{6.3.1 Module}
The Route \& Trip Module manages trip creation, storage, and retrieval for both drivers and riders.  
It enables users to post, view, and manage trip listings that include origin, destination, departure time, and available seats.  
This module provides the core data used by the Matching Module to pair drivers and riders based on spatial and temporal compatibility.

\paragraph{6.3.1.1 Frontend}
Implemented within the Expo mobile application, the frontend presents interactive screens and forms that allow users to create, browse, and manage trips.  
Key features include:
\begin{itemize}
    \item Trip creation form with origin, destination, date, and time pickers.
    \item Real-time map visualization of routes using a mapping API (e.g., Google Maps SDK).
    \item List and detail views for upcoming, active, and completed trips.
    \item Seat selection and trip cancellation interfaces for drivers.
    \item Integration with tRPC hooks such as \texttt{useCreateTrip()} and \texttt{useGetTrips()}.
    \item Validation feedback for missing fields or invalid time ranges.
\end{itemize}

\paragraph{6.3.1.2 Backend}
The backend implements business logic and trip operations through tRPC endpoints.  
It is responsible for managing trip lifecycle states and validating trip details before persistence.  
Primary responsibilities include:
\begin{itemize}
    \item Exposing API endpoints for trip creation, retrieval, and deletion.
    \item Validating trip parameters (valid coordinates, available seats, future departure time).
    \item Associating trips with authenticated users via BetterAuth sessions.
    \item Handling role-based permissions (drivers can create trips, riders can request rides).
    \item Broadcasting trip updates to relevant modules (Matching, Scheduling).
\end{itemize}
Typical procedures include \texttt{createTrip()}, \texttt{getTrips()}, and \texttt{cancelTrip()}.

\paragraph{6.3.1.3 Data}
Trip data is persisted in the PostgreSQL database via Drizzle ORM.  
The schema supports relational integrity between users, trips, and matches.  
Primary tables include:
\begin{itemize}
    \item \texttt{trips} — stores trip metadata: origin, destination, time, seats, and driver ID.
    \item \texttt{trip\_requests} — records ride requests by riders awaiting confirmation.
    \item \texttt{routes} — optional table caching route geometry and distance metrics.
\end{itemize}
Each record maintains timestamps for creation and modification, and all inserts are validated against foreign key constraints referencing the \texttt{users} table.

\subsubsection{6.3.2 Uses}
This module is used by both drivers and riders to manage travel logistics.  
It interacts directly with:
\begin{itemize}
    \item \textbf{User Profile Module} – links trips to driver and rider profiles.
    \item \textbf{Matching Module} – provides trip data for route and schedule-based matching.
    \item \textbf{Scheduling Module} – integrates recurring trips and time management.
    \item \textbf{Notification Module} – triggers updates for trip confirmations or cancellations.
\end{itemize}
It serves as the foundation for dynamic route pairing and trip coordination within the Hitchly system.

\subsubsection{6.3.3 Syntax}

\paragraph{6.3.3.1 Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_SEATS = 5} – Maximum allowable seats per trip.
    \item \texttt{TIME\_WINDOW\_MIN = 15} – Minimum departure buffer in minutes.
\end{itemize}

\paragraph{6.3.3.2 Exported Access Programs}
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{createTrip()} & TripData & TripRecord & ValidationError \\
\texttt{getTrips()} & userId, filters & TripList & NotFoundError \\
\texttt{cancelTrip()} & tripId & Confirmation & UnauthorizedError \\
\texttt{updateTrip()} & tripId, UpdatedFields & UpdatedTripRecord & ValidationError \\
\texttt{getTripById()} & tripId & TripRecord & NotFoundError \\
\bottomrule
\end{tabular}

\subsubsection{6.3.4 Semantics}

\paragraph{6.3.4.1 State Variables}
\begin{itemize}
    \item \texttt{activeTrips} – the current list of trips posted by the authenticated driver.
    \item \texttt{tripRequests} – ride requests awaiting driver approval.
    \item \texttt{tripCache} – locally cached trip data for offline viewing.
\end{itemize}

\paragraph{6.3.4.2 Environment Variables}
\begin{itemize}
    \item Mobile device GPS for route mapping.
    \item Network connection for fetching and updating trip data.
    \item PostgreSQL database via Drizzle ORM for persistent storage.
\end{itemize}

\paragraph{6.3.4.3 Assumptions}
\begin{itemize}
    \item The user is authenticated and verified before creating or editing a trip.
    \item The map service API key and geocoding are correctly configured.
    \item All database migrations have been applied prior to runtime.
\end{itemize}

\paragraph{6.3.4.4 Access Routine Semantics}

\texttt{createTrip()}:
\begin{itemize}
    \item \textbf{transition:} Inserts a new trip entry into the database associated with the user.
    \item \textbf{output:} Returns the newly created trip record.
    \item \textbf{exception:} ValidationError if trip data invalid or incomplete.
\end{itemize}

\texttt{getTrips()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns a filtered list of user or available trips.
    \item \textbf{exception:} NotFoundError if no trips exist for criteria.
\end{itemize}

\texttt{updateTrip()}:
\begin{itemize}
    \item \textbf{transition:} Modifies existing trip fields in database.
    \item \textbf{output:} Returns updated trip record.
    \item \textbf{exception:} ValidationError on invalid field or unauthorized edit.
\end{itemize}

\texttt{cancelTrip()}:
\begin{itemize}
    \item \textbf{transition:} Marks a trip as canceled and notifies dependent modules.
    \item \textbf{output:} Returns confirmation of cancellation.
    \item \textbf{exception:} UnauthorizedError if user lacks permission.
\end{itemize}

\texttt{getTripById()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns specific trip details by ID.
    \item \textbf{exception:} NotFoundError if ID does not exist.
\end{itemize}

\paragraph{6.3.4.5 Local Functions}
\begin{itemize}
    \item \texttt{calculateRouteDistance(origin, destination)} – Computes estimated distance and duration.
    \item \texttt{validateTripInput(tripData)} – Ensures all required fields and constraints are satisfied.
    \item \texttt{filterTripsByTime(trips, window)} – Returns only those trips within a certain time range.
\end{itemize}

\subsection{6.4 Matching Module}

\subsubsection{6.4.1 Module}
The Matching Module is the core algorithmic engine of Hitchly.  
It is responsible for generating ranked matches between riders and drivers based on route proximity, time compatibility, and ride preferences.  
This module applies the \textbf{Strategy Pattern} to maintain flexibility, allowing future replacement or enhancement of the scoring algorithm (e.g., machine learning or context-aware scoring).  
Its outputs drive the swipe-based interface, where users browse and select potential ride matches.

\paragraph{6.4.1.1 Frontend}
Implemented in the Expo mobile app, the frontend presents matches as interactive swipeable cards in a Tinder-style interface.  
Key features include:
\begin{itemize}
    \item Swipe gestures for liking or passing on potential matches.
    \item Real-time display of top recommended drivers or riders with route, time, and compatibility score.
    \item API integration through tRPC hooks (e.g., \texttt{useGetMatches()}, \texttt{useSubmitSwipe()}).
    \item Visual match indicators such as “Good Match” or percentage score badges.
    \item Smooth animations and immediate feedback for mutual matches.
\end{itemize}

\paragraph{6.4.1.2 Backend}
The backend implements the matchmaking logic within the Express/tRPC API, encapsulated in a dedicated service class (\texttt{MatchEngine}).  
The design follows the Strategy Pattern to keep scoring algorithms modular.  
Primary responsibilities include:
\begin{itemize}
    \item Retrieving candidate users and associated trips from the database.
    \item Filtering incompatible pairs by hard constraints: verified McMaster email, opposite roles, overlapping time windows, and nearby routes.
    \item Applying a scoring strategy (default: WeightedMatchStrategy) that computes a match score (0–100) using normalized factors.
    \item Sorting and returning the highest-scoring results to the frontend.
    \item Storing swipe actions and updating mutual matches.
\end{itemize}
The backend exposes tRPC endpoints such as \texttt{findMatchesForUser()}, \texttt{submitSwipe()}, and \texttt{getMatchResults()}.

\paragraph{6.4.1.3 Data}
The data layer maintains persistent records of matches, swipes, and scoring metrics within PostgreSQL via Drizzle ORM.  
Key tables include:
\begin{itemize}
    \item \texttt{matches} — stores confirmed mutual matches (rider ↔ driver) with timestamp and score.
    \item \texttt{swipes} — records all swipe actions for analytics and recommender tuning.
    \item \texttt{match\_history} — archives past matches for feedback and trust scoring.
\end{itemize}
Foreign keys link match records to both users and trips, ensuring referential integrity.

\subsubsection{6.4.2 Uses}
This module connects directly with:
\begin{itemize}
    \item \textbf{Route \& Trip Module} – provides trip data (origin, destination, departure time).
    \item \textbf{User Profile Module} – provides preference data and reliability rating.
    \item \textbf{Swipe Interaction Frontend} – renders and collects swipe input.
    \item \textbf{Notification Module} – notifies users upon mutual matches.
\end{itemize}
It is the computational bridge between trip listings and user engagement, supporting Hitchly’s key matchmaking feature.

\subsubsection{6.4.3 Syntax}

\paragraph{6.4.3.1 Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_CANDIDATES = 20} – limits results per query.
    \item \texttt{MATCH\_THRESHOLD = 0.6} – minimum normalized score to display.
\end{itemize}

\paragraph{6.4.3.2 Exported Access Programs}
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{findMatchesForUser()} & userId & RankedMatchList & NotFoundError \\
\texttt{submitSwipe()} & userId, targetId, swipeType & Confirmation & ValidationError \\
\texttt{getMatchResults()} & userId & MatchSummary & NotFoundError \\
\texttt{computeScore()} & rider, driver & Float (0–100) & AlgorithmError \\
\bottomrule
\end{tabular}

\subsubsection{6.4.4 Semantics}

\paragraph{6.4.4.1 State Variables}
\begin{itemize}
    \item \texttt{candidatePool} – list of drivers or riders retrieved for a user.
    \item \texttt{activeStrategy} – reference to the current scoring algorithm.
    \item \texttt{matchResults} – ordered list of potential matches with scores.
\end{itemize}

\paragraph{6.4.4.2 Environment Variables}
\begin{itemize}
    \item Active network connection for API queries.
    \item Database connection for retrieving and updating match data.
    \item Access to external map service for route distance calculations.
\end{itemize}

\paragraph{6.4.4.3 Assumptions}
\begin{itemize}
    \item Each user has an active, verified profile with trip data available.
    \item Distance and time calculations are performed via a reliable geocoding API.
    \item Only verified McMaster users participate in matching.
\end{itemize}

\paragraph{6.4.4.4 Access Routine Semantics}

\texttt{findMatchesForUser()}:
\begin{itemize}
    \item \textbf{transition:} Retrieves candidate list, filters, and scores matches.
    \item \textbf{output:} Returns ranked list of matches with normalized scores.
    \item \textbf{exception:} NotFoundError if no eligible candidates exist.
\end{itemize}

\texttt{submitSwipe()}:
\begin{itemize}
    \item \textbf{transition:} Records user’s swipe and updates match state if reciprocal.
    \item \textbf{output:} Confirmation of swipe or new match event.
    \item \textbf{exception:} ValidationError for invalid input or unauthorized user.
\end{itemize}

\texttt{getMatchResults()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns list of confirmed mutual matches.
    \item \textbf{exception:} NotFoundError if no matches found.
\end{itemize}

\texttt{computeScore()}:
\begin{itemize}
    \item \textbf{transition:} Applies active strategy to compute weighted match score.
    \item \textbf{output:} Floating-point score between 0 and 100.
    \item \textbf{exception:} AlgorithmError if scoring function fails.
\end{itemize}

\paragraph{6.4.4.5 Local Functions}
\begin{itemize}
    \item \texttt{applyFilters(user, candidate)} – evaluates eligibility constraints (distance, role, timing).
    \item \texttt{calculateWeightedScore(rider, driver)} – computes weighted sum using factors:
    \begin{itemize}
        \item Route overlap (35\%)
        \item Time compatibility (20\%)
        \item Preference alignment (15\%)
        \item Reliability rating (10\%)
        \item Social similarity (10\%)
        \item Match history (10\%)
    \end{itemize}
    \item \texttt{normalizeScore(raw)} – scales values into [0, 100].
\end{itemize}


\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable?
    \begin{itemize}
      \item \textbf{Aidan Froggatt:}  
      For me, the deliverable went well because I already had strong familiarity with our codebase and architectural decisions. Since I set up the initial project foundation—Turborepo structure, tRPC API, database schema, and BetterAuth configuration—I had a clear understanding of how the modules needed to be defined and integrated. This made it easier to produce accurate, consistent MIS entries. I also found that working through each module clarified how our system would scale and how responsibilities should be divided, which improved the overall coherence of the document.

      \item \textbf{[Team Member 2]:}  
      % Write your reflection here.

      \item \textbf{[Burhanuddin Kharodawala]:}  
    We had a good discussion as a group which helped me develop a better understanding of the overall content of this deliverable. Moreover, the template had clear understandings for most of the sections I worked on. 

      \item \textbf{[Team Member 4]:}  
      % Write your reflection here.

      \item \textbf{[Team Member 5]:}  
      % Write your reflection here.
    \end{itemize} 

  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
    \begin{itemize}
      \item \textbf{Aidan Froggatt:}  
      One of the main challenges for me was determining the correct level of abstraction for each module. Because I am so close to the actual implementation, it was easy to accidentally include too many low-level details. I had to step back and focus on “what” the module exposes rather than “how” it works internally. Another pain point was aligning terminology with the Module Guide—for example, ensuring naming consistency and clearly defining frontend, backend, and data responsibilities. I resolved these issues by revisiting the SRS and MG structure and adjusting my MIS sections to fit the expected style and rigor of the course.

      \item \textbf{[Team Member 2]:}  
      The document had a few ambiguous instructions which I had difficulty understanding. The module decomposition section specially was the one thing that was a little confusing. I was unsure of what the expectations were for the module. As in, what is a module (A feature or functionality)? At the end of the TA meeting however, I was able to discuss this with the TA and confirm the expectations for the modules.  

      \item \textbf{[Burhanuddin Kharodawala]:}  
      % Write your reflection here.

      \item \textbf{[Team Member 4]:}  
      % Write your reflection here.

      \item \textbf{[Team Member 5]:}  
      % Write your reflection here.      
    \end{itemize}

  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?

  As a team, many of our design choices originated from discussions with peers and user proxies. The idea to create a McMaster-only ridesharing platform emerged from user concerns around safety and trust. Our matching approach, including the swipe-based interface, was influenced by peer feedback indicating that a familiar interaction model would improve adoption.  
  Other decisions—such as using tRPC, BetterAuth, and Drizzle ORM—came from internal technical reasoning. These choices focused on maintainability, type safety, and long-term scalability rather than direct stakeholder input.


  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?

  During the MIS development, the team identified minor inconsistencies between the Module Guide, SRS, and earlier architectural descriptions. Some module names were standardized to ensure consistent referencing, and inter-module relationships were clarified, particularly for Matching, Scheduling, and Notification. A few requirement identifiers were refined to improve traceability. No core requirements changed, but descriptions were tightened to align with the finalized MIS structure.

  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)

  The current solution, while well-structured, is limited by capstone scope and development time. Our matching algorithm is deterministic and rule-based; with more resources, the team would implement machine-learning-driven adaptive matching.  
  Additional improvements could include:
  \begin{itemize}
      \item fully implemented CI/CD pipelines for automated testing and deployment,
      \item real-time route optimization using live traffic data,
      \item enhanced accessibility and UX refinement,
      \item automated moderation tools and trust scoring systems,
      \item end-to-end encryption and advanced safety features.
  \end{itemize}
  These expansions would elevate Hitchly from a functional prototype to a production-ready system.

  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  
  The team considered multiple architectural and implementation approaches. One option was to use a REST-based backend instead of tRPC, but this offered weaker type safety across the mobile app and API. Another option was building a native iOS/Android app, but Expo provided faster development and easier integration within the monorepo.  
  The team also explored using a monolithic architecture versus a modular service structure. Ultimately, the chosen modular design offered the best balance between clarity, extensibility, and meeting course expectations.  
  Alternative matching designs, such as a manually curated list instead of a scoring algorithm, were rejected because they reduced flexibility and diminished the quality of the user matching experience.  

  
  (LO\_Explores)
\end{enumerate}


\end{document}