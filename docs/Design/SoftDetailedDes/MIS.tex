\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\section{Revision History}

\begin{tabularx}{\textwidth}{llX}
\toprule
{\bf Date} & {\bf Developer} & {\bf Notes} \\
\midrule
November 7st & Aidan Froggatt & Completed Section 6.1, 6.2, 6.3, 6.4\\
November 11th & Swesan Pathmanathan & Completed Sections 1, 2, 4, 5, 6.5, 6.6, 6.7, 6.8 \\
November 12th & Burhan Kharodawala & Completed Sections 3, 6.9, 6.10, 6.11, 6.12\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at https://github.com/hitchly/hitchly/tree/main/docs/SRS

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  API & Application Programming Interface \\
  CRUD & Create, Read, Update, Delete \\
  DB & Database \\
  JWT & JSON Web Token \\
  ORM & Object-Relational Mapping \\
  UI & User Interface \\
  UX & User Experience \\
  tRPC & TypeScript Remote Procedure Calls \\
  SSO & Single Sign-On \\
  SDK & Software Development Kit \\
  GPS & Global Positioning System \\
  MFA & Multi-Factor Authentication \\
  OTP & One-Time Password \\
  HTTP & Hypertext Transfer Protocol \\
  HTTPS & Secure Hypertext Transfer Protocol \\
  Expo & React Native toolchain for mobile applications \\
  Stripe & Payment gateway service \\
  SQL & Structured Query Language \\
  DBMS & Database Management System \\
  ML & Machine Learning \\
  \progname & Hitchly rideshare system name \\
  \bottomrule
\end{tabular}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}
The following document details the Module Interface Specifications for Hitchtly, a rideshare application designed for the McMaster community. Its main purpose is to provide a reliable and trustworthy platform for McMaster students, staff and faculty members to find and provide rideshare services. It does it through its robust matching algorithm which matches users based on their timetable, location time, and preferences. It aims to make commuting to and from university sustainable and cost-effective.  
\\
Complementary documents include the System Requirement Specifications and Module Guide. The full documentation and implementation can be found at \href{https://github.com/hitchly/hitchly}. 

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.


\section{Module Decomposition} \label{SecMD}

\begingroup
\setlength{\parindent}{0pt}

Modules are decomposed according to the principle of information hiding
\citep{ParnasEtAl1984}.  
Each module’s \textit{Secrets} describes the internal design decision that is
intentionally hidden from other modules, while the \textit{Services} field specifies
\textit{what} the module provides without revealing \textit{how} the service is implemented.  
The \textit{Frontend UI}, \textit{API Logic}, and \textit{Database Models} indicate 
how each module is realized across the system’s architecture.  
\textit{Implemented By} identifies the technologies used, and 
\textit{Type of Module} classifies each module as a Behaviour-Hiding or 
Software-Decision module according to Section~\ref{SecMH}.  
Only the leaf modules are included.

% ---------------------------------------------------------
% BEHAVIOUR-HIDING MODULES
% ---------------------------------------------------------
\subsection*{Behaviour-Hiding Modules}

\subsubsection*{M1: Authentication \& Verification Module}
\begin{itemize}
  \item \textbf{Secrets:} Token/session strategy, email-verification workflow, and credential-validation logic.
  \item \textbf{Services:} Allows users to register, log in, and verify McMaster email accounts.
  \item \textbf{Frontend UI:} Login screens, signup forms, verification code UI.
  \item \textbf{API Logic:} \texttt{authRouter} (login, register, verify), session helpers, Zod validation.
  \item \textbf{Database Models:} \texttt{User} table (email, password hash, verified flag, session tokens).
  \item \textbf{Implemented By:} React Native (Expo) + tRPC backend with Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M2: User Profile Module}
\begin{itemize}
  \item \textbf{Secrets:} Role-assignment logic and profile-preference storage design.
  \item \textbf{Services:} Provides profile editing, preferences, and vehicle data management.
  \item \textbf{Frontend UI:} Profile page, edit forms, vehicle info inputs.
  \item \textbf{API Logic:} \texttt{userRouter} for CRUD operations, preference update flow.
  \item \textbf{Database Models:} \texttt{User}, \texttt{Vehicle}, \texttt{Preference}.
  \item \textbf{Implemented By:} React Native UI + tRPC + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M3: Route \& Trip Module}
\begin{itemize}
  \item \textbf{Secrets:} Trip-storage schema, route normalization, and time formatting.
  \item \textbf{Services:} Allows users to create, list, and cancel trips.
  \item \textbf{Frontend UI:} Trip creation form, trip list UI, route selection screen.
  \item \textbf{API Logic:} \texttt{tripRouter} for trip creation, querying, and deletion.
  \item \textbf{Database Models:} \texttt{Trip} table (origin, destination, time, seat count).
  \item \textbf{Implemented By:} React Native + tRPC backend + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M4: Matching Module}
\begin{itemize}
  \item \textbf{Secrets:} Scoring algorithm, distance/time weighting, and Strategy Pattern implementation.
  \item \textbf{Services:} Computes driver–rider compatibility and returns ordered match results.
  \item \textbf{Frontend UI:} Swipe-based card UI, match results list.
  \item \textbf{API Logic:} \texttt{matchmakingRouter}, MatchEngine (Strategy Pattern).
  \item \textbf{Database Models:} \texttt{Match}, \texttt{Swipe}.
  \item \textbf{Implemented By:} Node.js backend (tRPC) + algorithm utilities + Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M5: Scheduling Module}
\begin{itemize}
  \item \textbf{Secrets:} Recurring-trip generation algorithm and time-window parsing.
  \item \textbf{Services:} Creates recurring or one-time schedules linked to trips.
  \item \textbf{Frontend UI:} Time picker, recurring toggle, calendar UI.
  \item \textbf{API Logic:} Schedule parser and recurring schedule generator.
  \item \textbf{Database Models:} \texttt{Schedule} table.
  \item \textbf{Implemented By:} tRPC backend + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M6: Notification Module}
\begin{itemize}
  \item \textbf{Secrets:} Push-token handling and asynchronous event queue logic.
  \item \textbf{Services:} Sends push notifications for matches, cancellations, and reminders.
  \item \textbf{Frontend UI:} In-app notification center, Expo push integration.
  \item \textbf{API Logic:} Notification service with event emitters.
  \item \textbf{Database Models:} \texttt{Notification} table.
  \item \textbf{Implemented By:} Expo Push Service + tRPC backend dispatcher.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M7: Rating \& Feedback Module}
\begin{itemize}
  \item \textbf{Secrets:} Reputation computation and weighting logic.
  \item \textbf{Services:} Enables users to submit ratings and text feedback after trips.
  \item \textbf{Frontend UI:} Post-ride rating screen.
  \item \textbf{API Logic:} \texttt{ratingRouter}.
  \item \textbf{Database Models:} \texttt{Rating} table (linked to \texttt{Match}).
  \item \textbf{Implemented By:} React Native + tRPC + Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M8: Safety \& Reporting Module}
\begin{itemize}
  \item \textbf{Secrets:} Incident-flagging thresholds and safety-response workflow.
  \item \textbf{Services:} Allows reporting of unsafe behaviour and stores incidents for admin review.
  \item \textbf{Frontend UI:} Report button, safety resources screen.
  \item \textbf{API Logic:} Report submission via \texttt{reportRouter}.
  \item \textbf{Database Models:} \texttt{Report}.
  \item \textbf{Implemented By:} React Native + tRPC + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M9: Payment \& Cost Estimation Module}
\begin{itemize}
  \item \textbf{Secrets:} Fare-calculation logic and mock-payment validation.
  \item \textbf{Services:} Estimates ride cost and records payment confirmations.
  \item \textbf{Frontend UI:} Fare display, confirmation screen.
  \item \textbf{API Logic:} \texttt{paymentRouter}.
  \item \textbf{Database Models:} \texttt{Payment}, \texttt{Transaction}.
  \item \textbf{Implemented By:} tRPC backend + Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M10: Admin \& Moderation Module}
\begin{itemize}
  \item \textbf{Secrets:} Moderation rules, flagging thresholds, and admin-only access logic.
  \item \textbf{Services:} Allows admins to review reports, ban users, and view platform stats.
  \item \textbf{Frontend UI:} Admin dashboard (optional).
  \item \textbf{API Logic:} \texttt{adminRouter}.
  \item \textbf{Database Models:} Admin logs, flagged users.
  \item \textbf{Implemented By:} tRPC backend + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

% ---------------------------------------------------------
% SOFTWARE-DECISION MODULES
% ---------------------------------------------------------
\subsection*{Software-Decision Modules}

\subsubsection*{M11: Pricing Module}
\begin{itemize}
  \item \textbf{Secrets:} Fuel-rate constants, distance multipliers, and fare model.
  \item \textbf{Services:} Computes estimated trip price using distance and conditions.
  \item \textbf{Frontend UI:} Fare estimate displayed in trip preview.
  \item \textbf{API Logic:} Cost-calculation service reused by M9.
  \item \textbf{Database Models:} Pricing configuration constants.
  \item \textbf{Implemented By:} Node.js backend utilities + shared pricing helpers.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\subsubsection*{M12: Database Module}
\begin{itemize}
  \item \textbf{Secrets:} ORM mapping, schema decisions, and migration strategy.
  \item \textbf{Services:} Provides access to all persistent data models via a centralized DB client.
  \item \textbf{Frontend UI:} None.
  \item \textbf{API Logic:} Prisma client configuration and model exports.
  \item \textbf{Database Models:} All tables (User, Trip, Match, Schedule, etc.).
  \item \textbf{Implemented By:} Prisma ORM + PostgreSQL.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\endgroup

\section{MIS for Modules}

\subsection{Authentication \& Verification Module}

\subsubsection{Module}
The Authentication \& Verification Module manages user identity creation, secure login, and McMaster email verification for all Hitchly users.
This module is implemented using the \textbf{BetterAuth} authentication framework, which provides end-to-end session management, credential validation, and token-based verification. 
It ensures that only users with verified \texttt{@mcmaster.ca} emails can access the system's features.

\paragraph{Frontend}
The frontend component is integrated into the Expo mobile application.  
It provides the UI flow for login, signup, and verification.  
User input is collected through secure forms and sent to the backend via tRPC.  
The frontend handles the following:
\begin{itemize}
    \item Displays login and signup screens.
    \item Manages form validation and field state.
    \item Invokes BetterAuth client hooks for authentication (e.g., \texttt{useSignIn()}, \texttt{useSignUp()}).
    \item Handles redirect and session persistence after successful login.
    \item Presents error messages for invalid credentials or unverified accounts.
\end{itemize}

\paragraph{Backend}
The backend is implemented in the Express/tRPC API using \textbf{BetterAuth's server SDK}.  
It manages credential validation, session tokens, McMaster domain enforcement, and email verification logic.
Key backend operations include:
\begin{itemize}
    \item Configuring BetterAuth provider for the Hitchly API.
    \item Enforcing allowed email domains (\texttt{@mcmaster.ca}) during registration.
    \item Generating and validating secure verification tokens.
    \item Managing persistent user sessions through signed cookies and JWTs.
    \item Integrating with the email service for verification links.
\end{itemize}

\paragraph{Data}
The data layer persists authentication and verification information within the PostgreSQL database managed by Drizzle ORM.
BetterAuth automatically provisions and maintains required tables:
\begin{itemize}
    \item \texttt{users} --- stores user credentials, roles, and verification state.
    \item \texttt{sessions} --- stores active user sessions with expiry timestamps.
    \item \texttt{verification\_tokens} --- tracks issued and redeemed email verification tokens.
\end{itemize}
Data integrity is enforced by unique constraints on email and by transactional updates during verification.

\subsubsection{Uses}
This module ensures secure access to Hitchly by verifying each user's McMaster University affiliation.  
It interacts directly with:
\begin{itemize}
    \item \textbf{Frontend UI:} collects credentials and displays verification flows.
    \item \textbf{API Layer:} provides endpoints for signup, login, logout, and verification.
    \item \textbf{Database:} persists user and session data managed through BetterAuth.
\end{itemize}
All other modules depend on this component to validate user identity before allowing access to trip creation, matching, and messaging features.

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
    \item \texttt{ALLOWED\_DOMAIN = "@mcmaster.ca"}  
    Restricts signup to McMaster-affiliated emails.
    \item \texttt{SESSION\_EXPIRY = 24h}  
    Sets the maximum lifetime for user sessions.
\end{itemize}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{registerUser()} & name, email, password & verificationToken & DuplicateEmailError \\
\texttt{loginUser()} & email, password & sessionToken & InvalidCredentialsError \\
\texttt{verifyEmail()} & verificationToken & successFlag & ExpiredTokenError \\
\texttt{logoutUser()} & sessionToken & confirmation & InvalidSessionError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{isVerified: bool} --- indicates whether the user's email has been confirmed.
    \item \texttt{authToken: string} --- stores the active session token generated by BetterAuth.
    \item \texttt{sessionState: object} --- holds session metadata for frontend persistence.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
    \item User device input (keyboard, network, mobile UI).
    \item Secure HTTPS connection to API.
    \item Email server or transactional service for verification emails.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
    \item All users have valid McMaster email accounts.
    \item Database migrations and BetterAuth setup scripts have been executed.
    \item Network connectivity is stable during registration or verification.
\end{itemize}

\paragraph{Access Routine Semantics}

\texttt{registerUser()}:
\begin{itemize}
    \item \textbf{transition:} Inserts a new pending user into the database and triggers a verification email.
    \item \textbf{output:} Returns a token or link for verification.
    \item \textbf{exception:} Thrown if email already exists or invalid domain detected.
\end{itemize}

\texttt{loginUser()}:
\begin{itemize}
    \item \textbf{transition:} Validates credentials and creates a session.
    \item \textbf{output:} Returns a signed JWT or session cookie.
    \item \textbf{exception:} InvalidCredentialsError if authentication fails.
\end{itemize}

\texttt{verifyEmail()}:
\begin{itemize}
    \item \textbf{transition:} Updates user's \texttt{isVerified} state to true.
    \item \textbf{output:} Returns success confirmation.
    \item \textbf{exception:} ExpiredTokenError if verification link invalid or expired.
\end{itemize}

\texttt{logoutUser()}:
\begin{itemize}
    \item \textbf{transition:} Revokes session in \texttt{sessions} table.
    \item \textbf{output:} Confirmation of logout.
    \item \textbf{exception:} InvalidSessionError if session token not found.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{generateVerificationToken(): string} --- Creates a cryptographically secure token.
    \item \texttt{validateEmailDomain(email: string): boolean} --- Ensures domain ends with \texttt{@mcmaster.ca}.
    \item \texttt{hashPassword(password: string): string} --- Applies secure hashing for stored credentials.
\end{itemize}

\subsection{User Profile Module}

\subsubsection{Module}
The User Profile Module manages all personal and contextual information about a Hitchly user.  
It allows students, alumni, and faculty to view and edit their personal data, preferences, and role (rider, driver, or both).  
This module integrates directly with the Authentication \& Verification Module for identity linkage and with the Matching Module to supply accurate data for matchmaking.

\paragraph{Frontend}
The frontend portion resides in the Expo mobile application.  
It provides interfaces for profile creation, editing, and display, implemented using shared UI components.  
Key features include:
\begin{itemize}
    \item Editable profile screen showing name, faculty, year, and role.
    \item Driver-specific section for vehicle information (make, model, seats).
    \item Preference selection for quiet/chatty rides, music, and other comfort options.
    \item Integration with camera/gallery for optional profile photo upload.
    \item Form validation and error messaging for incomplete or invalid fields.
    \item Communication with backend via tRPC hooks (e.g., \texttt{useGetUser()}, \texttt{useUpdateUser()}).
\end{itemize}

\paragraph{Backend}
The backend implements the business logic and data orchestration using Express and tRPC.  
It exposes endpoints for retrieving, updating, and deleting user data.  
Main responsibilities include:
\begin{itemize}
    \item Providing tRPC procedures such as \texttt{getUserProfile}, \texttt{updateUserProfile}, and \texttt{deleteUser}.
    \item Validating incoming payloads using Zod schemas for type safety.
    \item Enforcing access control through session validation from BetterAuth.
    \item Maintaining referential integrity with linked tables (e.g., trips, ratings).
    \item Broadcasting profile updates to dependent modules (e.g., Matching, Analytics).
\end{itemize}

\paragraph{Data}
The data layer defines persistent entities stored in PostgreSQL via Drizzle ORM.  
Key tables include:
\begin{itemize}
    \item \texttt{users} --- stores user metadata such as name, role, faculty, and profile image URL.
    \item \texttt{vehicles} --- stores driver vehicle details and capacity.
    \item \texttt{preferences} --- stores personal ride preferences and settings.
\end{itemize}
All tables use foreign-key constraints to maintain one-to-one or one-to-many relationships with user records.  
Schema migrations ensure consistent structure across environments.

\subsubsection{Uses}
This module is used to manage user data required across the entire Hitchly system.  
It interacts with:
\begin{itemize}
    \item \textbf{Authentication \& Verification Module} - links verified user identity to profile records.
    \item \textbf{Matching Module} - provides profile and preference data for scoring algorithms.
    \item \textbf{Trip Management Module} - associates user profiles with created or joined trips.
    \item \textbf{Rating \& Feedback Module} - aggregates ride feedback to display reliability metrics.
\end{itemize}
Through these integrations, the module forms the foundation of personalization and trust within Hitchly.

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_BIO\_LENGTH = 250} - Limits user biography text.
    \item \texttt{DEFAULT\_ROLE = "rider"} - Assigned when a user first registers.
\end{itemize}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{getUserProfile()} & userId & UserRecord & NotFoundError \\
\texttt{updateUserProfile()} & userId, ProfileData & UpdatedRecord & ValidationError \\
\texttt{deleteUser()} & userId & Confirmation & UnauthorizedError \\
\texttt{getUserPreferences()} & userId & PreferenceData & NotFoundError \\
\texttt{updatePreferences()} & userId, PreferenceData & UpdatedPreference & ValidationError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{userProfile} - Stores the current user information in application state.
    \item \texttt{preferences} - Represents the user's ride comfort and behavior choices.
    \item \texttt{vehicleData} - Contains driver-specific car details for eligible users.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
    \item Mobile UI components and device storage for temporary profile caching.
    \item Active API connection through HTTPS/tRPC.
    \item Database connection via Drizzle ORM.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
    \item The user is authenticated and verified before modifying profile data.
    \item The database schema has been migrated to include required tables.
    \item Frontend validation is performed prior to API submission.
\end{itemize}

\paragraph{Access Routine Semantics}

\texttt{getUserProfile()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns the user's profile record.
    \item \textbf{exception:} NotFoundError if record absent.
\end{itemize}

\texttt{updateUserProfile()}:
\begin{itemize}
    \item \textbf{transition:} Updates profile fields in database.
    \item \textbf{output:} Returns updated record.
    \item \textbf{exception:} ValidationError for invalid input or missing fields.
\end{itemize}

\texttt{updatePreferences()}:
\begin{itemize}
    \item \textbf{transition:} Rewrites preference entries linked to user ID.
    \item \textbf{output:} Confirmation of successful update.
    \item \textbf{exception:} ValidationError on schema violation.
\end{itemize}

\texttt{deleteUser()}:
\begin{itemize}
    \item \textbf{transition:} Removes user and related data (soft delete or cascade).
    \item \textbf{output:} Success confirmation.
    \item \textbf{exception:} UnauthorizedError if requester lacks privilege.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{sanitizeProfileInput(data)} - Removes disallowed fields and formats strings.
    \item \texttt{mergePreferenceDefaults(prefs)} - Applies default values for missing preference options.
    \item \texttt{calculateReliabilityScore(userId)} - Computes user trust metric from ratings and trip history.
\end{itemize}

\subsection{Route \& Trip Module}

\subsubsection{Module}
The Route \& Trip Module manages trip creation, storage, and retrieval for both drivers and riders.  
It enables users to post, view, and manage trip listings that include origin, destination, departure time, and available seats.  
This module provides the core data used by the Matching Module to pair drivers and riders based on spatial and temporal compatibility.

\paragraph{Frontend}
Implemented within the Expo mobile application, the frontend presents interactive screens and forms that allow users to create, browse, and manage trips.  
Key features include:
\begin{itemize}
    \item Trip creation form with origin, destination, date, and time pickers.
    \item Real-time map visualization of routes using a mapping API (e.g., Google Maps SDK).
    \item List and detail views for upcoming, active, and completed trips.
    \item Seat selection and trip cancellation interfaces for drivers.
    \item Integration with tRPC hooks such as \texttt{useCreateTrip()} and \texttt{useGetTrips()}.
    \item Validation feedback for missing fields or invalid time ranges.
\end{itemize}

\paragraph{Backend}
The backend implements business logic and trip operations through tRPC endpoints.  
It is responsible for managing trip lifecycle states and validating trip details before persistence.  
Primary responsibilities include:
\begin{itemize}
    \item Exposing API endpoints for trip creation, retrieval, and deletion.
    \item Validating trip parameters (valid coordinates, available seats, future departure time).
    \item Associating trips with authenticated users via BetterAuth sessions.
    \item Handling role-based permissions (drivers can create trips, riders can request rides).
    \item Broadcasting trip updates to relevant modules (Matching, Scheduling).
\end{itemize}
Typical procedures include \texttt{createTrip()}, \texttt{getTrips()}, and \texttt{cancelTrip()}.

\paragraph{Data}
Trip data is persisted in the PostgreSQL database via Drizzle ORM.  
The schema supports relational integrity between users, trips, and matches.  
Primary tables include:
\begin{itemize}
    \item \texttt{trips} --- stores trip metadata: origin, destination, time, seats, and driver ID.
    \item \texttt{trip\_requests} --- records ride requests by riders awaiting confirmation.
    \item \texttt{routes} --- optional table caching route geometry and distance metrics.
\end{itemize}
Each record maintains timestamps for creation and modification, and all inserts are validated against foreign key constraints referencing the \texttt{users} table.

\subsubsection{Uses}
This module is used by both drivers and riders to manage travel logistics.  
It interacts directly with:
\begin{itemize}
    \item \textbf{User Profile Module} - links trips to driver and rider profiles.
    \item \textbf{Matching Module} - provides trip data for route and schedule-based matching.
    \item \textbf{Scheduling Module} - integrates recurring trips and time management.
    \item \textbf{Notification Module} - triggers updates for trip confirmations or cancellations.
\end{itemize}
It serves as the foundation for dynamic route pairing and trip coordination within the Hitchly system.

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_SEATS = 5} - Maximum allowable seats per trip.
    \item \texttt{TIME\_WINDOW\_MIN = 15} - Minimum departure buffer in minutes.
\end{itemize}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{createTrip()} & TripData & TripRecord & ValidationError \\
\texttt{getTrips()} & userId, filters & TripList & NotFoundError \\
\texttt{cancelTrip()} & tripId & Confirmation & UnauthorizedError \\
\texttt{updateTrip()} & tripId, UpdatedFields & UpdatedTripRecord & ValidationError \\
\texttt{getTripById()} & tripId & TripRecord & NotFoundError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{activeTrips} - the current list of trips posted by the authenticated driver.
    \item \texttt{tripRequests} - ride requests awaiting driver approval.
    \item \texttt{tripCache} - locally cached trip data for offline viewing.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
    \item Mobile device GPS for route mapping.
    \item Network connection for fetching and updating trip data.
    \item PostgreSQL database via Drizzle ORM for persistent storage.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
    \item The user is authenticated and verified before creating or editing a trip.
    \item The map service API key and geocoding are correctly configured.
    \item All database migrations have been applied prior to runtime.
\end{itemize}

\paragraph{Access Routine Semantics}

\texttt{createTrip()}:
\begin{itemize}
    \item \textbf{transition:} Inserts a new trip entry into the database associated with the user.
    \item \textbf{output:} Returns the newly created trip record.
    \item \textbf{exception:} ValidationError if trip data invalid or incomplete.
\end{itemize}

\texttt{getTrips()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns a filtered list of user or available trips.
    \item \textbf{exception:} NotFoundError if no trips exist for criteria.
\end{itemize}

\texttt{updateTrip()}:
\begin{itemize}
    \item \textbf{transition:} Modifies existing trip fields in database.
    \item \textbf{output:} Returns updated trip record.
    \item \textbf{exception:} ValidationError on invalid field or unauthorized edit.
\end{itemize}

\texttt{cancelTrip()}:
\begin{itemize}
    \item \textbf{transition:} Marks a trip as canceled and notifies dependent modules.
    \item \textbf{output:} Returns confirmation of cancellation.
    \item \textbf{exception:} UnauthorizedError if user lacks permission.
\end{itemize}

\texttt{getTripById()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns specific trip details by ID.
    \item \textbf{exception:} NotFoundError if ID does not exist.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{calculateRouteDistance(origin, destination)} - Computes estimated distance and duration.
    \item \texttt{validateTripInput(tripData)} - Ensures all required fields and constraints are satisfied.
    \item \texttt{filterTripsByTime(trips, window)} - Returns only those trips within a certain time range.
\end{itemize}

\subsection{Matching Module}

\subsubsection{Module}
The Matching Module is the core algorithmic engine of Hitchly.  
It is responsible for generating ranked matches between riders and drivers based on route proximity, time compatibility, and ride preferences.  
This module applies the \textbf{Strategy Pattern} to maintain flexibility, allowing future replacement or enhancement of the scoring algorithm (e.g., machine learning or context-aware scoring).  
Its outputs drive the swipe-based interface, where users browse and select potential ride matches.

\paragraph{Frontend}
Implemented in the Expo mobile app, the frontend presents matches as interactive swipeable cards in a Tinder-style interface.  
Key features include:
\begin{itemize}
    \item Swipe gestures for liking or passing on potential matches.
    \item Real-time display of top recommended drivers or riders with route, time, and compatibility score.
    \item API integration through tRPC hooks (e.g., \texttt{useGetMatches()}, \texttt{useSubmitSwipe()}).
    \item Visual match indicators such as “Good Match” or percentage score badges.
    \item Smooth animations and immediate feedback for mutual matches.
\end{itemize}

\paragraph{Backend}
The backend implements the matchmaking logic within the Express/tRPC API, encapsulated in a dedicated service class (\texttt{MatchEngine}).  
The design follows the Strategy Pattern to keep scoring algorithms modular.  
Primary responsibilities include:
\begin{itemize}
    \item Retrieving candidate users and associated trips from the database.
    \item Filtering incompatible pairs by hard constraints: verified McMaster email, opposite roles, overlapping time windows, and nearby routes.
    \item Applying a scoring strategy (default: WeightedMatchStrategy) that computes a match score (0-100) using normalized factors.
    \item Sorting and returning the highest-scoring results to the frontend.
    \item Storing swipe actions and updating mutual matches.
\end{itemize}
The backend exposes tRPC endpoints such as \texttt{findMatchesForUser()}, \texttt{submitSwipe()}, and \texttt{getMatchResults()}.

\paragraph{Data}
The data layer maintains persistent records of matches, swipes, and scoring metrics within PostgreSQL via Drizzle ORM.  
Key tables include:
\begin{itemize}
    \item \texttt{matches} --- stores confirmed mutual matches (rider <-> driver) with timestamp and score.
    \item \texttt{swipes} --- records all swipe actions for analytics and recommender tuning.
    \item \texttt{match\_history} --- archives past matches for feedback and trust scoring.
\end{itemize}
Foreign keys link match records to both users and trips, ensuring referential integrity.

\subsubsection{Uses}
This module connects directly with:
\begin{itemize}
    \item \textbf{Route \& Trip Module} - provides trip data (origin, destination, departure time).
    \item \textbf{User Profile Module} - provides preference data and reliability rating.
    \item \textbf{Swipe Interaction Frontend} - renders and collects swipe input.
    \item \textbf{Notification Module} - notifies users upon mutual matches.
\end{itemize}
It is the computational bridge between trip listings and user engagement, supporting Hitchly's key matchmaking feature.

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_CANDIDATES = 20} - limits results per query.
    \item \texttt{MATCH\_THRESHOLD = 0.6} - minimum normalized score to display.
\end{itemize}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{findMatchesForUser()} & userId & RankedMatchList & NotFoundError \\
\texttt{submitSwipe()} & userId, targetId, swipeType & Confirmation & ValidationError \\
\texttt{getMatchResults()} & userId & MatchSummary & NotFoundError \\
\texttt{computeScore()} & rider, driver & Float (0-100) & AlgorithmError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{candidatePool} - list of drivers or riders retrieved for a user.
    \item \texttt{activeStrategy} - reference to the current scoring algorithm.
    \item \texttt{matchResults} - ordered list of potential matches with scores.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
    \item Active network connection for API queries.
    \item Database connection for retrieving and updating match data.
    \item Access to external map service for route distance calculations.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
    \item Each user has an active, verified profile with trip data available.
    \item Distance and time calculations are performed via a reliable geocoding API.
    \item Only verified McMaster users participate in matching.
\end{itemize}

\paragraph{Access Routine Semantics}

\texttt{findMatchesForUser()}:
\begin{itemize}
    \item \textbf{transition:} Retrieves candidate list, filters, and scores matches.
    \item \textbf{output:} Returns ranked list of matches with normalized scores.
    \item \textbf{exception:} NotFoundError if no eligible candidates exist.
\end{itemize}

\texttt{submitSwipe()}:
\begin{itemize}
    \item \textbf{transition:} Records user's swipe and updates match state if reciprocal.
    \item \textbf{output:} Confirmation of swipe or new match event.
    \item \textbf{exception:} ValidationError for invalid input or unauthorized user.
\end{itemize}

\texttt{getMatchResults()}:
\begin{itemize}
    \item \textbf{transition:} None (read-only).
    \item \textbf{output:} Returns list of confirmed mutual matches.
    \item \textbf{exception:} NotFoundError if no matches found.
\end{itemize}

\texttt{computeScore()}:
\begin{itemize}
    \item \textbf{transition:} Applies active strategy to compute weighted match score.
    \item \textbf{output:} Floating-point score between 0 and 100.
    \item \textbf{exception:} AlgorithmError if scoring function fails.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{applyFilters(user, candidate)} - evaluates eligibility constraints (distance, role, timing).
    \item \texttt{calculateWeightedScore(rider, driver)} - computes weighted sum using factors:
    \begin{itemize}
        \item Route overlap (35\%)
        \item Time compatibility (20\%)
        \item Preference alignment (15\%)
        \item Reliability rating (10\%)
        \item Social similarity (10\%)
        \item Match history (10\%)
    \end{itemize}
    \item \texttt{normalizeScore(raw)} - scales values into [0, 100].
\end{itemize}

% ============================================================
% 6.5 Scheduling Module
% ============================================================

\subsection{Scheduling Module}

\subsubsection{Module}
The Scheduling Module manages recurring and one-time ride schedules for drivers and riders.
It allows users to automate trip creation, define weekly patterns, and ensures that recurring schedules generate valid trip entries.  
This module integrates directly with the Trip Module and the Notification Module.

\paragraph{Frontend}
Implemented in the Expo app, the frontend provides UI controls for defining recurring or one-time schedules.

Key capabilities:
\begin{itemize}
    \item Time picker for selecting departure time
    \item Day-of-week toggles for recurring schedules
    \item Interface to view and cancel existing schedules
    \item Integration with tRPC hooks such as \texttt{useCreateSchedule()}, \texttt{useGetUserSchedules()}
    \item Form validation for time ranges and required fields
\end{itemize}

\paragraph{Backend}
The backend implements scheduling logic via tRPC.

Responsibilities include:
\begin{itemize}
    \item Parsing user-defined recurrence patterns
    \item Generating future trips based on schedules
    \item Ensuring schedules do not conflict with existing trips
    \item Validating schedule timing (future date, valid days)
    \item Exposing procedures such as \texttt{createSchedule()}, \texttt{cancelSchedule()}
\end{itemize}

\paragraph{Data}
The module persists schedule definitions and generated trip associations.

Tables:
\begin{itemize}
    \item \texttt{schedules} --- recurring schedule definitions (days, time, userId)
    \item \texttt{schedule\_instances} --- maps schedules to generated trips
    \item \texttt{trips} --- created by this module but stored by Trip Module
\end{itemize}

\subsubsection{Uses}
\begin{itemize}
    \item Trip Module --- creates trip entries from schedules
    \item User Profile Module --- determines valid schedule types
    \item Notification Module --- sends reminders for upcoming rides
\end{itemize}

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_RECURRING\_YEARS = 1}
    \item \texttt{VALID\_DAYS = [Mon..Sun]}
\end{itemize}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
Name & In & Out & Exceptions \\
\midrule
\texttt{createSchedule()} & scheduleData & ScheduleRecord & ValidationError \\
\texttt{getUserSchedules()} & userId & ScheduleList & NotFoundError \\
\texttt{cancelSchedule()} & scheduleId & Confirmation & UnauthorizedError \\
\texttt{generateFutureTrips()} & scheduleId & TripList & AlgorithmError \\
\bottomrule
\end{tabular}
}
\end{center}


\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{userSchedules}
    \item \texttt{activeRules}
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
    \item System scheduler
    \item Device timezone
    \item Database connection
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
    \item Users must be verified before scheduling
    \item Database schema is correctly migrated
\end{itemize}

\paragraph{Access Routine Semantics}

\texttt{createSchedule()}:
\begin{itemize}
    \item \textbf{transition:} Inserts schedule into DB
    \item \textbf{output:} Returns schedule record
\end{itemize}

\texttt{generateFutureTrips()}:
\begin{itemize}
    \item \textbf{transition:} Generates future trips
    \item \textbf{output:} List of trips
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{parseRecurrenceRule()}
    \item \texttt{nextOccurrence()}
\end{itemize}


% ============================================================
% 6.6 Notification Module
% ============================================================

\subsection{Notification Module}

\subsubsection{Module}
The Notification Module handles system alerts including match notifications, trip updates, and reminders.

\paragraph{Frontend}
Implemented via Expo Notifications.

UI responsibilities:
\begin{itemize}
    \item Requesting push permission
    \item Displaying notification center
    \item Handling tap events
\end{itemize}

Frontend integration:
\begin{itemize}
    \item \texttt{useRegisterPushToken()}
    \item \texttt{useGetNotifications()}
\end{itemize}

\paragraph{Backend}
Backend procedures manage dispatch and retrieval:
\begin{itemize}
    \item Storing device push tokens
    \item Sending push messages via Expo Push API
    \item Queueing async notification events
    \item Procedures: \texttt{sendNotification()}, \texttt{markAsRead()}
\end{itemize}

\paragraph{Data}
\begin{itemize}
    \item \texttt{notifications} --- stored messages
    \item \texttt{push\_tokens} --- device tokens
\end{itemize}

\subsubsection{Uses}
\begin{itemize}
    \item Matching Module --- notifies mutual matches
    \item Scheduling Module --- sends reminders
    \item Trip Module --- alerts cancellations
\end{itemize}

\subsubsection{Syntax}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
Name & In & Out & Exceptions \\
\midrule
\texttt{sendNotification()} & userId, message & Confirmation & DeliveryError \\
\texttt{getNotifications()} & userId & NotificationList & NotFoundError \\
\texttt{markAsRead()} & notificationId & Confirmation & UnauthorizedError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{queuedNotifications}
    \item \texttt{readStatus}
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
    \item Expo Push Service
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{formatNotificationPayload()}
    \item \texttt{enqueueNotification()}
\end{itemize}


% ============================================================
% 6.7 Rating & Feedback Module
% ============================================================

\subsection{Rating \& Feedback Module}

\subsubsection{Module}
This module collects and stores ride ratings and feedback, updating reliability scores used by the Matching Module.

\paragraph{Frontend}
UI elements:
\begin{itemize}
    \item Post-ride rating screen
    \item Optional text feedback box
    \item History of past ratings
\end{itemize}

Hooks:
\begin{itemize}
    \item \texttt{useSubmitRating()}
    \item \texttt{useGetUserRatings()}
\end{itemize}

\paragraph{Backend}
Backend responsibilities:
\begin{itemize}
    \item Validating rating payloads
    \item Linking ratings to matches
    \item Recomputing reliability scores
    \item Procedures: \texttt{submitRating()}, \texttt{calculateReliability()}
\end{itemize}

\paragraph{Data}
Tables:
\begin{itemize}
    \item \texttt{ratings}
    \item \texttt{reliability\_metrics}
\end{itemize}

\subsubsection{Uses}
\begin{itemize}
    \item Matching Module --- reliability score as weighted factor
    \item User Profile Module --- shows aggregated rating
\end{itemize}

\subsubsection{Syntax}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
Name & In & Out & Exceptions \\
\midrule
\texttt{submitRating()} & ratingData & Confirmation & ValidationError \\
\texttt{getUserRatings()} & userId & RatingList & NotFoundError \\
\texttt{calculateReliability()} & userId & Score & AlgorithmError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{recentRatings}
    \item \texttt{reliabilityScore}
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{computeWeightedAverage()}
    \item \texttt{sanitizeComment()}
\end{itemize}


% ============================================================
% 6.8 Safety & Reporting Module
% ============================================================

\subsection{Safety \& Reporting Module}

\subsubsection{Module}
This module manages user-submitted safety reports and flags, assisting platform moderation.

\paragraph{Frontend}
Includes:
\begin{itemize}
    \item Report User form
    \item Safety resources page
\end{itemize}

Hooks:
\begin{itemize}
    \item \texttt{useSubmitReport()}
\end{itemize}

\paragraph{Backend}
Backend responsibilities:
\begin{itemize}
    \item Validating and storing incident reports
    \item Assigning severity scores
    \item Procedures: \texttt{submitReport()}, \texttt{resolveReport()}
\end{itemize}

\paragraph{Data}
Tables include:
\begin{itemize}
    \item \texttt{reports}
    \item \texttt{safety\_flags}
\end{itemize}

\subsubsection{Uses}
\begin{itemize}
    \item Admin \& Moderation Module
    \item Notification Module
\end{itemize}

\subsubsection{Syntax}

\paragraph{Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
Name & In & Out & Exceptions \\
\midrule
\texttt{submitReport()} & reportData & Confirmation & ValidationError \\
\texttt{getReports()} & userId/adminId & ReportList & UnauthorizedError \\
\texttt{resolveReport()} & reportId, action & Confirmation & PermissionError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
    \item \texttt{pendingReports}
    \item \texttt{userSafetyStatus}
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
    \item \texttt{categorizeSeverity()}
    \item \texttt{flagUser()}
    \item \texttt{closeReport()}
\end{itemize}



%------

\subsection{Payment Module}

\subsubsection{Module}
This module is responsible for handling in-app user payments. The implementation of this module will be done through Stripe. This acts as a payment gateway to ensure a secure transaction and successful payment.  

\paragraph{6.9.1.1 Frontend}
The frontend of this application will be implemented using the Expo Client Application. A payment screen would display a form to fill out the required information for processing the payment. This includes the user's full name, mailing address, payment method, and payment information (i.e., Credit Card Number, etc.). For other methods of payment (i.e., Google Pay, PayPal, etc.), the frontend will be implemented to manage redirection. Upon a successful transaction, the user can select an option to go back to the home screen.  

\paragraph{6.9.1.2 Backend}
The backend will receive the inputs from frontend and validate the user and ride data. It is then responsible for processing the payment via calling payment gateway API to authorize the payment method and details. It will open a secure session to process the payment and get the state (i.e., payment successful, processing, error) to display as the output. Lastly, this component will ensure that the transaction is recorded in the database and that receipts have been sent to the user's emails.  

\paragraph{6.9.1.3 Data}
The database component is responsible for storing the user's payment history, ride details, and transaction information.  

\subsubsection{Uses}
This module ensures secure access to Hitchly by verifying each user's McMaster University affiliation.  
It interacts directly with:
\begin{itemize}
    \item \textbf{User Profile Module:} This is used to retrieve user profile details for verification. 
    \item \textbf{Route \& Trip Module:} This is used to retrieve trip details like cost, ID, etc.
    \item \textbf{Database Module:} This is used to store trip transaction details into the database.  
\end{itemize}

\subsubsection{Syntax}

\paragraph{6.9.3.1 Exported Constants}
\begin{itemize}
    \item \texttt{max\_attempt = 4}  
    Maximum attempts to make a transaction before they have to wait for 30 minutes. 
    \item \texttt{max\_session = 25}  
    Maximum allowed time (in minutes) for a session to process the payment before it throws a processing error. 
\end{itemize}

\paragraph{6.9.3.2 Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{init\_payment()} & user\_id, ride\_id & Boolean (verified or unverified) & NotFoundError \\
\texttt{process\_payment()} & payment\_id, payment\_method  & payment_status  & ExpiredSessionError \\
\texttt{get\_paymentRecord()} & payment\_id, user\_id, ride\_id & paymentRecord & NotFoundError \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{6.9.4.1 State Variables}
\begin{itemize}
    \item \texttt{current\_amount: float} --- holds the current amount for the transaction.
    \item \texttt{session\_token: string} --- holds the current amount for the transaction.
    \item \texttt{sessionState: object} --- holds session metadata for frontend persistence.
\end{itemize}

\paragraph{6.9.4.2 Environment Variables}
\begin{itemize}
    \item Secure HTTPS connection to API.
    \item Secure API connection to payment gateways.
\end{itemize}

\paragraph{6.9.4.3 Assumptions}
\begin{itemize}
    \item The users won't intentionally input expired or invalid credentials.
    \item The API connection is secure and stable throughout the payment process.
    \item The payment gateways will handle user's confidential information securely.
\end{itemize}

\paragraph{6.9.4.4 Access Routine Semantics}

\texttt{init\_payment()}:
\begin{itemize}
    \item \textbf{transition:} None
    \item \textbf{output:} Bool (user verified for the specific ride or not)
    \item \textbf{exception:} NotFoundError, user or ride not found.
\end{itemize}

\texttt{Process\_payment()}:
\begin{itemize}
    \item \textbf{transition:} Initializes connection with the API.
    \item \textbf{output:} Returns whether the payment is succesful, processing or failed.
    \item \textbf{exception:} ExpiredSessionError if the session fails to process the payment due to session limits.
\end{itemize}

\texttt{get\_paymentRecord()}:
\begin{itemize}
    \item \textbf{transition:} Creates a payment record.
    \item \textbf{output:} List of payment records.
    \item \textbf{exception:} NotFoundError if one of the required parameters is missing.
\end{itemize}


\paragraph{6.9.4.5 Local Functions}
\begin{itemize}
    \item \texttt{generateVerificationToken(): string} --- Creates a cryptographically secure token.
\end{itemize}

%----

\subsection{Database Module}

\subsubsection{Module}
This module is responsible for handling all database-related functionalities and ensuring smooth communication between the database servers for retrieving and updating data. This includes user information, ride details, transaction logs, etc. 

\paragraph{6.10.1.1 Frontend}
N/A

\paragraph{6.10.1.2 Backend}
The backend layer of this module handles CRUD operations for core system entities and manages communication between the application and the database for smooth retrieval and update of application data. 

\paragraph{6.10.1.3 Data}
This layer will store a schema of tables used across multiple modules. This includes: 
\begin{itemize}
    \item \textbf{User Table:} This stores all critical profile information of the user.
    \item \textbf{Ride Table:} This stores all critical ride details.
    \item \textbf{Payment Table:} This stores the user transactions for each ride.
    \item \textbf{Safety Report Table:} This stores all user safety reports.
    \item \textbf{Admin Table:} This stores the user's role details.
\end{itemize}

\subsubsection{Uses}
\begin{itemize}
    \item \textbf{User Profile Module:} This is used to retrieve and store user profile details.
    \item \textbf{Route \& Trip Module:} This is used to retrieve and store trip details like cost, ID, etc.
    \item \textbf{Payment Module:} This is used to retrieve and store user's transaction details.
    \item \textbf{Safety and Reporting Module:} This is used to retrieve and store user reports.
    \item \textbf{Admin Module:} This is used to retrieve and store admin details.
\end{itemize}


\subsubsection{Syntax}

\paragraph{6.10.3.1 Exported Constants}
\begin{itemize}
    \item \texttt{max\_connect  = 30}  
    This is the maximum number of database connections at a time. 
    \item \texttt{max\_attempt = 4}  
    Maximum attempts made to connect to db before the connection fails. 
    \item \texttt{max\_DB\_session = 30}  
    30 minutes limit before the session times out.
\end{itemize}

\paragraph{6.10.3.2 Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{addRecord()} & tablename, data & Boolean & NotFoundError, InvalidDataFormatException, DBTimeoutException \\
\texttt{updateRecord()} & tablename, data, record\_id & Boolean & NotFoundError, InvalidDataFormatException, DBTimeoutException \\
\texttt{deleteRecord()} & tablename, record\_id & Boolean & NotFoundError, InvalidDataFormatException, DBTimeoutException \\
\texttt{getRecord()} & tablename, data\_condition & List of data records & NotFoundError, InvalidDataFormatException, DBTimeoutException \\
\texttt{getAllRecords()} & tablename & List of data records & NotFoundError, InvalidDataFormatException, DBTimeoutException \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{6.10.4.1 State Variables}
\begin{itemize}
    \item \texttt{DBConnections: List<connections>} --- List of active database connections.
\end{itemize}

\paragraph{6.10.4.2 Environment Variables}
\begin{itemize}
    \item Secure HTTPS connection to API.
    \item Secure API connection and communication the database server.
    \item Secure connection to local/cloud backup services for data backup.    
\end{itemize}

\paragraph{6.10.4.3 Assumptions}
\begin{itemize}
    \item The Postgress database is avaiable and securely stores data.
    \item The database has sufficient storage capacity.
    \item The database automatically runs its data backup services to ensure that no data is lost.
\end{itemize}

\paragraph{6.10.4.4 Access Routine Semantics}

\texttt{addRecord()}:
\begin{itemize}
    \item \textbf{transition:} A new entry is added to the specified table.
    \item \textbf{output:} Bool (True or False, depending on the state of the transition).
    \item \textbf{exception:} NotFoundError (table not found), InvalidDataFormatException, DBTimeoutException.
\end{itemize}

\texttt{updateRecord()}:
\begin{itemize}
    \item \textbf{transition:} An existing entry is updated in the specified table.
    \item \textbf{output:} Bool (True or False, depending on the state of the transition).
    \item \textbf{exception:} NotFoundError (table or entry not found), InvalidDataFormatException, DBTimeoutException.
\end{itemize}

\texttt{deleteRecord()}:
\begin{itemize}
    \item \textbf{transition:} An existing entry is deleted in the specified table.
    \item \textbf{output:} Bool (True or False, depending on the state of the transition).
    \item \textbf{exception:} NotFoundError (table or entry not found), InvalidDataFormatException, DBTimeoutException.
\end{itemize}

\texttt{getRecord()}:
\begin{itemize}
    \item \textbf{transition:} None.
    \item \textbf{output:} Returns a list of indicated records.
    \item \textbf{exception:} NotFoundError (table not found), DBTimeoutException.
\end{itemize}

\texttt{getAllRecords()}:
\begin{itemize}
    \item \textbf{transition:} None.
    \item \textbf{output:} Returns a list of all records.
    \item \textbf{exception:} NotFoundError (table not found), DBTimeoutException.
\end{itemize}

\paragraph{6.10.4.5 Local Functions}
\begin{itemize}
    \item \texttt{db\_connect(): bool} --- This is to initialize a connection with the database service.
    \item \texttt{checkFormat(): bool} --- This function checks if the inserted data aligns with the specified schema.
\end{itemize}

% -------

\subsection{Pricing Module}

\subsubsection{Module}
This module handles the initial cost estimation functionality of the application. 

\paragraph{6.11.1.1 Frontend}
This layer provides the UI for displaying the factors influencing the price per ride, along with a price estimation for it. It dynamically updates the price as new rides join the ride for a specific ride. 

\paragraph{6.11.1.2 Backend}
This layer provides the algorithm to use those factors and accurately calculate the cost estimation for each rider for a given trip. It interacts with the Google Maps API to fetch location and distance values. Additionally, it sends this data to the payment module for processing the final payment for each rider. 

\paragraph{6.11.1.3 Data}
The database component is responsible for storing the following table:
\begin{itemize}
    \item \textbf{Pricing Table:} Contains data related to pricing as per the parameters.
    \item \textbf{Ride Table:} Contains data related to ride details.
\end{itemize}

\subsubsection{Uses}
\begin{itemize}
    \item \textbf{User Profile Module:} This is used to retrieve the user type.
    \item \textbf{Database Module:} This is used to retrieve and store pricing details.
    \item \textbf{Route \& Trip Module:} This is used to retrieve and store trip details like cost, ID, etc.
    \item \textbf{Payment Module:} The final cost estimation from this module is sent to the payment module.
\end{itemize}


\subsubsection{Syntax}

\paragraph{6.11.3.1 Exported Constants}
\begin{itemize} 
    \item \texttt{max\_session\_time = 30}  
    30 minutes limit before the API session times out.
\end{itemize}

\paragraph{6.11.3.2 Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{get\_ride\_summary()} & rideID & ride\_summary & NotFoundError \\
\texttt{estimate\_cost()} & start\_location, end\_location, rider\_count & fare\_estimate & InvalidLocationException, APITimeOutException \\
\texttt{update\_fare()} & new\_rider\_count & updated\_fare & APITimeOutException \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{6.11.4.1 State Variables}
N/A

\paragraph{6.11.4.2 Environment Variables}
\begin{itemize}
    \item Secure HTTPS connection to API.
    \item Secure Maps API connection for accurate estimation of travel time and distance.
    \item Secure API connections to get daily fuel rates.    
\end{itemize}

\paragraph{6.11.4.3 Assumptions}
\begin{itemize}
    \item The external API services function properly with minimal downtime. 
    \item The fuel estimates online are accurate.
    \item The internet connection stays stable during the cost estimation process.
\end{itemize}


\paragraph{6.11.4.4 Access Routine Semantics}

\texttt{get\_ride\_summary()}:
\begin{itemize}
    \item \textbf{transition:} None.
    \item \textbf{output:} Returns a ride summary object.
    \item \textbf{exception:} NotFoundError (ride not found).
\end{itemize}

\texttt{estimate\_cost()}:
\begin{itemize}
    \item \textbf{transition:} Retrieves information from API and updates database tables.
    \item \textbf{output:} Fare\_estimate, returns an estimated price value.
    \item \textbf{exception:} InvalidLocationException, APITimeOutException.
\end{itemize}

\texttt{update\_fare()}:
\begin{itemize}
    \item \textbf{transition:} Retrieves information from API and updates database tables.
    \item \textbf{output:} Updated\_fare, returns an estimated price value.
    \item \textbf{exception:} APITimeOutException.
\end{itemize}


\paragraph{6.11.4.5 Local Functions}
\begin{itemize}
    \item \texttt{validate\_parameters(start\_location, end\_location, rider\_count): bool} --- Check if the values are not negative and are valid inputs.
\end{itemize}

%----------

\subsection{Admin/Moderation Module}

\subsubsection{Module}
This module handles the distribution of user roles and management of admin controls. This also controls and monitors activity and ensures strict policy enforcement.

\paragraph{6.12.1.1 Frontend}
This layer is responsible for providing an admin dashboard with flagged content, user complaints, user roles, and application analytics. 

\paragraph{6.12.1.2 Backend}
This layer is responsible for handling communication with RESTAPI endpoints using AdminRouter to manage user accounts and rides. Additionally, it runs the logic for handling role-based authentication. 

\paragraph{6.12.1.3 Data}
\begin{itemize}
    \item \textbf{Admin Table:} This would include profile information about admin.
    \item \textbf{Ride Table:} This would include information about users with warnings/bans.
    \item \textbf{User Analytics Table:} This includes a dataset of user and application statistics.
\end{itemize}

\subsubsection{Uses}
\begin{itemize}
    \item \textbf{Database Module:} This is used to retrieve and store pricing details.
    \item \textbf{Authentication \& Verification Module:} This is used to manage admin login and permissions.
\end{itemize}

\subsubsection{Syntax}

\paragraph{6.12.3.1 Exported Constants}
\begin{itemize} 
    \item \texttt{warning\_threshold= 3}  
    Maximum warnings before putting an account ban.
\end{itemize}

\paragraph{6.12.3.2 Exported Access Programs}
\par\vspace{0.5em}

\begin{center}
\resizebox{\textwidth}{!}{
\begin{tabular}{l l l l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{warn\_user()} & user\_ID, reason & Bool (check if user is successfully warned) & NotFoundError, InsufficientAdminPrivileges \\
\texttt{get\_Reports()} & None & Returns a dataset of user reports & NotFoundError, InsufficientAdminPrivileges \\
\texttt{get\_analytics()} & None & Returns a dataset of user and application statistics & NotFoundError, InsufficientAdminPrivileges \\
\bottomrule
\end{tabular}
}
\end{center}

\subsubsection{Semantics}

\paragraph{6.12.4.1 State Variables}
N/A

\paragraph{6.12.4.2 Environment Variables}
\begin{itemize}
    \item Secure HTTPS connection to API.
    \item Secure API connection for stable admin controls and management.  
\end{itemize}

\paragraph{6.12.4.3 Assumptions}
\begin{itemize}
    \item All admin permissions function properly. 
    \item All database services are full functional and stable.
    \item All API connections are functional and stable.
\end{itemize}


\paragraph{6.12.4.4 Access Routine Semantics}

\texttt{warn\_user()}:
\begin{itemize}
    \item \textbf{transition:} Adds a new record with a warning in the reports table.
    \item \textbf{output:} Bool (check if user is successfully warned).
    \item \textbf{exception:} NotFoundError (user\_ID not found), InsufficientAdminPrivileges.
\end{itemize}

\texttt{get\_Reports()}:
\begin{itemize}
    \item \textbf{transition:} None.
    \item \textbf{output:} Returns a dataset of user reports.
    \item \textbf{exception:} NotFoundError (empty dataset), InsufficientAdminPrivileges.
\end{itemize}

\texttt{get\_analytics()}:
\begin{itemize}
    \item \textbf{transition:} None.
    \item \textbf{output:} Returns a dataset of user and application statistics.
    \item \textbf{exception:} NotFoundError (empty dataset), InsufficientAdminPrivileges.
\end{itemize}


\paragraph{6.12.4.5 Local Functions}
\begin{itemize}
    \item \texttt{check\_privilege(admin\_ID, endpoint): bool} --- This function validates admin privileges and returns a bool to indicate whether they have sufficient privileges or not.
\end{itemize}

%-------------------




\section{Appendix} \label{Appendix}


\newpage{}

\section*{Appendix --- Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable?
    \begin{itemize}
      \item \textbf{Aidan Froggatt:}  
      For me, the deliverable went well because I already had strong familiarity with our codebase and architectural decisions. Since I set up the initial project foundation---Turborepo structure, tRPC API, database schema, and BetterAuth configuration---I had a clear understanding of how the modules needed to be defined and integrated. This made it easier to produce accurate, consistent MIS entries. I also found that working through each module clarified how our system would scale and how responsibilities should be divided, which improved the overall coherence of the document.

      \item \textbf{Swesan:} 
      The previous documents (such as the SRS and the earlier drafts) had already established much of the conceptual groundwork, which made defining the modules relatively straightforward. Since we entered this deliverable with a strong understanding of the system’s structure, identifying responsibilities and writing the Module Guide flowed naturally. I personally worked on Section 5 (Module Hierarchy) and Section 7, and having those earlier documents as references made the process efficient and focused.

      \item \textbf{[Burhanuddin Kharodawala]:}  
    We had a good discussion as a group which helped me develop a better understanding of the overall content of this deliverable. Moreover, the template had clear understandings for most of the sections I worked on. 
    \end{itemize} 

  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
    \begin{itemize}
      \item \textbf{Aidan Froggatt:}  
      One of the main challenges for me was determining the correct level of abstraction for each module. Because I am so close to the actual implementation, it was easy to accidentally include too many low-level details. I had to step back and focus on “what” the module exposes rather than “how” it works internally. Another pain point was aligning terminology with the Module Guide---for example, ensuring naming consistency and clearly defining frontend, backend, and data responsibilities. I resolved these issues by revisiting the SRS and MG structure and adjusting my MIS sections to fit the expected style and rigor of the course.

      \item \textbf{Swesan:}  
       One of the main challenges was determining which modules were truly necessary and how to group or separate functionality without creating modules that were too abstract or too fragmented. Our initial draft had 15 modules, but after careful discussion and iterative refinement, we narrowed it down to 12 well-defined modules that better reflect the system’s actual behaviour and design principles. We resolved this by comparing responsibilities, identifying overlaps, and merging modules where appropriate while ensuring each remaining module had a clear secret, purpose, and boundary.   

      \item \textbf{[Burhanuddin Kharodawala]:}  
      The document had a few ambiguous instructions which I had difficulty understanding. The module decomposition section especially was the one thing that was a little confusing. I was unsure of what the expectations were for the module. As in, what is a module (A feature or functionality)? At the end of the TA meeting however, I was able to discuss this with the TA and confirm the expectations for the modules.     
    \end{itemize}

  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?

  As a team, many of our design choices originated from discussions with peers and user proxies. The idea to create a McMaster-only ridesharing platform emerged from user concerns around safety and trust. Our matching approach, including the swipe-based interface, was influenced by peer feedback indicating that a familiar interaction model would improve adoption.  
  Other decisions---such as using tRPC, BetterAuth, and Drizzle ORM---came from internal technical reasoning. These choices focused on maintainability, type safety, and long-term scalability rather than direct stakeholder input.


  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?

  During the MIS development, the team identified minor inconsistencies between the Module Guide, SRS, and earlier architectural descriptions. Some module names were standardized to ensure consistent referencing, and inter-module relationships were clarified, particularly for Matching, Scheduling, and Notification. A few requirement identifiers were refined to improve traceability. No core requirements changed, but descriptions were tightened to align with the finalized MIS structure.

  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)

  The current solution, while well-structured, is limited by capstone scope and development time. Our matching algorithm is deterministic and rule-based; with more resources, the team would implement machine-learning-driven adaptive matching.  
  Additional improvements could include:
  \begin{itemize}
      \item fully implemented CI/CD pipelines for automated testing and deployment,
      \item real-time route optimization using live traffic data,
      \item enhanced accessibility and UX refinement,
      \item automated moderation tools and trust scoring systems,
      \item end-to-end encryption and advanced safety features.
  \end{itemize}
  These expansions would elevate Hitchly from a functional prototype to a production-ready system.

  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  
  The team considered multiple architectural and implementation approaches. One option was to use a REST-based backend instead of tRPC, but this offered weaker type safety across the mobile app and API. Another option was building a native iOS/Android app, but Expo provided faster development and easier integration within the monorepo.  
  The team also explored using a monolithic architecture versus a modular service structure. Ultimately, the chosen modular design offered the best balance between clarity, extensibility, and meeting course expectations.  
  Alternative matching designs, such as a manually curated list instead of a scoring algorithm, were rejected because they reduced flexibility and diminished the quality of the user matching experience.  

  
  (LO\_Explores)
\end{enumerate}

\bibliographystyle{plainnat}
\bibliography{../../../refs/References}

\end{document}
