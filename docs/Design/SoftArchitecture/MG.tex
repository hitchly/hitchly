\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  AC & Anticipated Change\\
  DAG & Directed Acyclic Graph \\
  M & Module \\
  MG & Module Guide \\
  OS & Operating System \\
  R & Requirement\\
  SC & Scientific Computing \\
  SRS & Software Requirements Specification\\
  \progname & Explanation of program name\\
  UC & Unlikely Change \\
  \wss{etc.} & \wss{...}\\
  \bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing
software.  A module is a work assignment for a programmer or programming
team~\citep{ParnasEtAl1984}.  We advocate a decomposition
based on the principle of information hiding~\citep{Parnas1972a}.  This
principle supports design for change, because the ``secrets'' that each module
hides represent likely future changes.  Design for change is valuable in SC,
where modifications are frequent, especially during initial development as the
solution space is explored.  

Our design follows the rules layed out by \citet{ParnasEtAl1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the
  secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\citep{ParnasEtAl1984}. The MG
specifies the modular structure of the system and is intended to allow both
designers and maintainers to easily identify the parts of the software.  The
potential readers of this document are as follows:

\begin{itemize}
\item New project members: This document can be a guide for a new project member
  to easily understand the overall structure and quickly find the
  relevant modules they are searching for.
\item Maintainers: The hierarchical structure of the module guide improves the
  maintainers' understanding when they need to make changes to the system. It is
  important for a maintainer to update the relevant sections of the document
  after changes have been made.
\item Designers: Once the module guide has been written, it can be used to
  check for consistency, feasibility, and flexibility. Designers can verify the
  system in various ways, such as consistency among modules, feasibility of the
  decomposition, and flexibility of the design.
\end{itemize}

The rest of the document is organized as follows. Section
\ref{SecChange} lists the anticipated and unlikely changes of the software
requirements. Section \ref{SecMH} summarizes the module decomposition that
was constructed according to the likely changes. Section \ref{SecConnection}
specifies the connections between the software requirements and the
modules. Section \ref{SecMD} gives a detailed description of the
modules. Section \ref{SecTM} includes two traceability matrices. One checks
the completeness of the design against the requirements provided in the SRS. The
other shows the relation between anticipated changes and the modules. Section
\ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system. According to the likeliness
of the change, the possible changes are classified into two
categories. Anticipated changes are listed in Section \ref{SecAchange}, and
unlikely changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. The approach
adapted here is called design for
change.

\begin{description}
\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific
  hardware on which the software is running.
\item[\refstepcounter{acnum} \actheacnum \label{acInput}:] The format of the
  initial input data.
\item ...
\end{description}

\wss{Anticipated changes relate to changes that would be made in requirements,
design or implementation choices.  They are not related to changes that are made
at run-time, like the values of parameters.}

\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible. However, a general system is
more complex. Sometimes this complexity is not necessary. Fixing some design
decisions at the system architecture stage can simplify the software design. If
these decision should later need to be changed, then many parts of the design
will potentially need to be modified. Hence, it is not intended that these
decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum \label{ucIO}:] Input/Output devices
  (Input: File and/or Keyboard, Output: File, Memory, and/or Screen).
\item ...
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design. Modules are summarized
in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed
below, which are leaves in the hierarchy tree, are the modules that will
actually be implemented.

\begin{description}
\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module
\item ...
\end{description}


\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & ?\\
& ?\\
& ?\\
& ?\\
& ?\\
& ?\\
& ?\\ 
& ?\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} & {?}\\
& ?\\
& ?\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in
the SRS. In this stage, the system is decomposed into modules. The connection
between requirements and modules is listed in Table~\ref{TblRT}.

\wss{The intention of this section is to document decisions that are made
  ``between'' the requirements and the design.  To satisfy some requirements,
  design decisions need to be made.  Rather than make these decisions implicit,
  they are explicitly recorded here.  For instance, if a program has security
  requirements, a specific design decision may be made to satisfy those
  requirements with a password.}

\section{Module Decomposition} \label{SecMD}

\begingroup
\setlength{\parindent}{0pt}

Modules are decomposed according to the principle of information hiding
\citep{ParnasEtAl1984}.  
Each module’s \emph{Secrets} field describes the internal design decision that is
hidden, while the \emph{Services} field specifies \emph{what} the module provides
without detailing \emph{how}.  
\emph{Implemented By} identifies the software or subsystem that realizes the
module, and \emph{Type of Module} classifies it as Hardware-Hiding,
Behaviour-Hiding, or Software-Decision.  
Only the leaf modules from Section~\ref{SecMH} are included.

\subsection*{Hardware-Hiding Modules}

These modules provide abstraction from physical device hardware and OS APIs,
ensuring portability and isolating device-dependent changes.

\subsubsection*{M1: GPS Module}
\begin{itemize}
  \item \textbf{Secrets:} How the app accesses and optimizes GPS data, including sampling rate, accuracy, and permission handling.
  \item \textbf{Services:} Provides real-time coordinates and continuous tracking used for routing, pricing, and ride matching.
  \item \textbf{Implemented By:} React Native Location API and Expo Location.
  \item \textbf{Type of Module:} Hardware-Hiding Module.
\end{itemize}

\subsubsection*{M2: Camera Module}
\begin{itemize}
  \item \textbf{Secrets:} Camera access configuration, resolution settings, and permission control.
  \item \textbf{Services:} Captures photos for license, ID, and profile verification; processes images for upload.
  \item \textbf{Implemented By:} Expo Camera API and React Native Permissions.
  \item \textbf{Type of Module:} Hardware-Hiding Module.
\end{itemize}

\subsection*{Behaviour-Hiding Modules}

These modules implement Hitchly’s user-visible behaviours and external interactions.
They hide workflow logic, API details, and data representations from the end user.

\subsubsection*{M3: Verification Module}
\begin{itemize}
  \item \textbf{Secrets:} Identity-validation logic, including SSO integration and license verification algorithms.
  \item \textbf{Services:} Verifies users through McMaster SSO authentication and driver-license uploads, interacting with the Camera Module for photo capture.
  \item \textbf{Implemented By:} Node.js (Express) backend integrated with McMaster SSO and third-party verification APIs.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M4: Authentication Module}
\begin{itemize}
  \item \textbf{Secrets:} Token management and session lifetime configuration.
  \item \textbf{Services:} Handles user login, registration, and secure JWT refresh.
  \item \textbf{Implemented By:} Node.js + tRPC backend with PostgreSQL user store and JWT middleware.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M5: Matching Module}
\begin{itemize}
  \item \textbf{Secrets:} Ride-matching algorithm and ranking heuristics based on route and time overlap.
  \item \textbf{Services:} Matches riders and drivers, returns ranked ride options, and records confirmed pairings.
  \item \textbf{Implemented By:} Node.js backend using Mapbox API and PostgreSQL.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M6: Mapping Module}
\begin{itemize}
  \item \textbf{Secrets:} API-key management and caching strategy for rendering maps and computing routes.
  \item \textbf{Services:} Displays maps, computes distances and ETAs, and provides coordinates for pricing and matching.
  \item \textbf{Implemented By:} React Native frontend using Google Maps / Mapbox SDK.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M7: Payment Module}
\begin{itemize}
  \item \textbf{Secrets:} Payment-flow design and validation logic for cost-sharing transactions.
  \item \textbf{Services:} Handles transactions, manages fare splitting, and stores payment records.
  \item \textbf{Implemented By:} Node.js backend integrated with a Stripe-like API and PostgreSQL.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M8: Database Module}
\begin{itemize}
  \item \textbf{Secrets:} Schema definitions, indexing strategies, and ORM mappings.
  \item \textbf{Services:} Provides persistent data storage and structured query interfaces for all other modules.
  \item \textbf{Implemented By:} PostgreSQL database accessed via Drizzle ORM in Node.js backend.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M9: Notification Module}
\begin{itemize}
  \item \textbf{Secrets:} Message-queue structure and token-based delivery mechanism for push notifications.
  \item \textbf{Services:} Sends trip confirmations, cancellations, and safety alerts through the Expo Push Notification Service.
  \item \textbf{Implemented By:} Expo Push Service API with backend dispatcher in Node.js.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M10: Rating Module}
\begin{itemize}
  \item \textbf{Secrets:} Scoring and weighting logic for user-reputation computation.
  \item \textbf{Services:} Records ratings, aggregates averages, and updates driver and rider reputations.
  \item \textbf{Implemented By:} Node.js microservice with PostgreSQL + Drizzle ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M11: Search Module}
\begin{itemize}
  \item \textbf{Secrets:} Search indexing and filtering logic for ride listings.
  \item \textbf{Services:} Enables users to search rides by date, location, and preference filters.
  \item \textbf{Implemented By:} Node.js backend using PostgreSQL full-text search.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsection*{Software-Decision Modules}

These modules contain Hitchly’s internal logic and algorithms invisible to users.
They implement data analysis, computation, scheduling, and enforcement mechanisms.

\subsubsection*{M12: Analytics Module}
\begin{itemize}
  \item \textbf{Secrets:} Data-aggregation and metric-computation methods for sustainability and usage tracking.
  \item \textbf{Services:} Collects anonymized usage data and generates reports for performance monitoring.
  \item \textbf{Implemented By:} Backend analytics engine using Node.js and PostgreSQL scheduled jobs.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\subsubsection*{M13: Scheduling Module}
\begin{itemize}
  \item \textbf{Secrets:} Trip allocation and time-slot management algorithm.
  \item \textbf{Services:} Manages ride creation, modifications, and cancellations while preventing overlap conflicts.
  \item \textbf{Implemented By:} Node.js backend with Drizzle ORM transactional logic.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\subsubsection*{M14: Safety Module}
\begin{itemize}
  \item \textbf{Secrets:} Safety-policy enforcement logic and verification thresholds.
  \item \textbf{Services:} Oversees ride safety checks, monitors incidents, and handles emergency triggers.
  \item \textbf{Implemented By:} Node.js backend integrated with Verification and Notification modules.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\subsubsection*{M15: Pricing Module}
\begin{itemize}
  \item \textbf{Secrets:} Fare-calculation formula and cost-sharing model parameters.
  \item \textbf{Services:} Computes ride prices and divides costs among passengers based on route and occupancy.
  \item \textbf{Implemented By:} Node.js backend using Mapping and Scheduling data.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\endgroup


\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

% the table should use mref, the requirements should be named, use something
% like fref
\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Req.} & \textbf{Modules}\\
\midrule
R1 & \mref{mHH}, \mref{mInput}, \mref{mParams}, \mref{mControl}\\
R2 & \mref{mInput}, \mref{mParams}\\
R3 & \mref{mVerify}\\
R4 & \mref{mOutput}, \mref{mControl}\\
R5 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
R6 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
R7 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
R8 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
R9 & \mref{mVerifyOut}\\
R10 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}\\
R11 & \mref{mOutput}, \mref{mODEs}, \mref{mEnergy}, \mref{mControl}\\
\bottomrule
\end{tabular}
\caption{Trace Between Requirements and Modules}
\label{TblRT}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{AC} & \textbf{Modules}\\
\midrule
\acref{acHardware} & \mref{mHH}\\
\acref{acInput} & \mref{mInput}\\
\acref{acParams} & \mref{mParams}\\
\acref{acVerify} & \mref{mVerify}\\
\acref{acOutput} & \mref{mOutput}\\
\acref{acVerifyOut} & \mref{mVerifyOut}\\
\acref{acODEs} & \mref{mODEs}\\
\acref{acEnergy} & \mref{mEnergy}\\
\acref{acControl} & \mref{mControl}\\
\acref{acSeqDS} & \mref{mSeqDS}\\
\acref{acSolver} & \mref{mSolver}\\
\acref{acPlot} & \mref{mPlot}\\
\bottomrule
\end{tabular}
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is
provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if
correct execution of B may be necessary for A to complete the task described in
its specification. That is, A {\em uses} B if there exist situations in which
the correct functioning of A depends upon the availability of a correct
implementation of B.  Figure \ref{FigUH} illustrates the use relation between
the modules. It can be seen that the graph is a directed acyclic graph
(DAG). Each level of the hierarchy offers a testable and usable subset of the
system, and modules in the higher level of the hierarchy are essentially simpler
because they use modules from the lower levels.

\wss{The uses relation is not a data flow diagram.  In the code there will often
be an import statement in module A when it directly uses module B.  Module B
provides the services that module A needs.  The code for module A needs to be
able to see these services (hence the import statement).  Since the uses
relation is transitive, there is a use relation without an import, but the
arrows in the diagram typically correspond to the presence of import statement.}

\wss{If module A uses module B, the arrow is directed from A to B.}

\begin{figure}[H]
\centering
%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
\caption{Use hierarchy among modules}
\label{FigUH}
\end{figure}

%\section*{References}

\section{User Interfaces}

\wss{Design of user interface for software and hardware.  Attach an appendix if
needed. Drawings, Sketches, Figma}

\section{Design of Communication Protocols}

This section describes the design of the communication protocols implemented in Hitchly.
Communication occurs primarily between the client‐side mobile application (developed
with React Native / Expo) and the backend server (implemented with Node.js, Express,
and tRPC).  The system also integrates third-party APIs for geolocation and notifications.

\subsection{11.1 Overall Architecture}

All communication between the mobile client and the backend follows a request–response
model over HTTPS, ensuring confidentiality and integrity.  Data is serialized in JSON
format and transferred through REST and type-safe tRPC endpoints.  The architecture
adopts a modular service-based design to support scalability and maintainability:

\begin{itemize}
  \item \textbf{Frontend (Client):} React Native app that sends authenticated requests
  to backend endpoints via HTTPS using the tRPC client.
  \item \textbf{Backend (Server):} Express server exposing routes through the tRPC API layer.
  It validates and processes incoming requests, interacts with the PostgreSQL database
  through Drizzle ORM, and returns structured JSON responses.
  \item \textbf{External Services:} Mapping and geolocation (Google Maps / Mapbox API),
  Expo Push Notification Service for alerts, and optional OAuth verification via McMaster
  SSO (for email validation).
\end{itemize}

\subsection{11.2 Communication Flow}

A typical data exchange involves the following sequence:

\begin{enumerate}
  \item The user performs an action in the mobile application (e.g., requests a ride,
  updates schedule, or rates a driver).
  \item The frontend constructs a tRPC call encapsulating the action data and attaches
  the user’s JWT authentication token in the header.
  \item The server authenticates the request, validates input schemas, and executes the
  corresponding service logic.
  \item The backend queries or updates PostgreSQL through Drizzle ORM and returns a
  success or error payload to the client.
  \item The client updates its UI state using React Query based on the received data.
\end{enumerate}

\subsection{11.3 API Endpoints and Message Types}

Hitchly’s backend exposes the following logical API groups:

\begin{itemize}
  \item \textbf{Auth API:} Handles user registration, login, McMaster email verification,
  and token refresh.  Exchanges encrypted credentials and JWT tokens.
  \item \textbf{User API:} Manages user profiles, schedules, and preferences.
  \item \textbf{Matching API:} Accepts commute data, performs matching algorithm, and
  returns ranked ride offers.
  \item \textbf{Trip API:} Records completed trips, generates summaries, and calculates
  cost-sharing.
  \item \textbf{Rating API:} Sends and retrieves ratings and reviews.
  \item \textbf{Notification API:} Uses Expo Push Notification service to deliver trip
  confirmations, cancellations, and updates in real time.
\end{itemize}

All messages follow the JSON structure:
\begin{verbatim}
{
  "status": "success",
  "data": { ... },
  "timestamp": "2025-01-03T12:00:00Z"
}
\end{verbatim}

\subsection{11.4 Security and Reliability}

Security and reliability are ensured through:

\begin{itemize}
  \item \textbf{Transport Security:} HTTPS with TLS 1.3 and HSTS enforcement.
  \item \textbf{Authentication:} JWT Bearer tokens included in headers of all authorized
  requests.
  \item \textbf{Input Validation:} All incoming payloads validated using Zod schemas in
  tRPC to prevent injection or malformed data.
  \item \textbf{Error Handling:} Standardized error codes with human-readable messages
  returned to the client.
  \item \textbf{Rate Limiting:} Express middleware limits excessive requests to prevent
  abuse.
  \item \textbf{Retry Mechanism:} Client-side React Query retries transient network
  failures automatically.
\end{itemize}

\subsection{11.5 Design Considerations}

The communication design of Hitchly emphasizes the following principles:

\begin{itemize}
  \item \textbf{Consistency:} Shared TypeScript types across frontend and backend
  guarantee end-to-end type safety through tRPC.
  \item \textbf{Extensibility:} Additional endpoints (e.g., payment API or advanced analytics)
  can be introduced without modifying existing client modules.
  \item \textbf{Scalability:} The stateless REST/tRPC design supports horizontal scaling
  of the Express server behind a load balancer.
  \item \textbf{Low Latency:} JSON over HTTPS is lightweight; caching of common responses
  and asynchronous notification delivery minimize perceived delay.
\end{itemize}

This design ensures secure, efficient, and maintainable communication between Hitchly’s
mobile application, backend, and external services, supporting its goals of safety,
reliability, and sustainability for McMaster commuters.


\section{Timeline}

\wss{Schedule of tasks and who is responsible}

\wss{You can point to GitHub if this information is included there}

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage{}

\end{document}