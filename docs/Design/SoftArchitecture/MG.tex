\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  AC & Anticipated Change\\
  DAG & Directed Acyclic Graph \\
  M & Module \\
  MG & Module Guide \\
  OS & Operating System \\
  R & Requirement\\
  SC & Scientific Computing \\
  SRS & Software Requirements Specification\\
  \progname & Explanation of program name\\
  UC & Unlikely Change \\
  \wss{etc.} & \wss{...}\\
  \bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing
software.  A module is a work assignment for a programmer or programming
team~\citep{ParnasEtAl1984}.  We advocate a decomposition
based on the principle of information hiding~\citep{Parnas1972a}.  This
principle supports design for change, because the ``secrets'' that each module
hides represent likely future changes.  Design for change is valuable in SC,
where modifications are frequent, especially during initial development as the
solution space is explored.  

Our design follows the rules layed out by \citet{ParnasEtAl1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the
  secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\citep{ParnasEtAl1984}. The MG
specifies the modular structure of the system and is intended to allow both
designers and maintainers to easily identify the parts of the software.  The
potential readers of this document are as follows:

\begin{itemize}
\item New project members: This document can be a guide for a new project member
  to easily understand the overall structure and quickly find the
  relevant modules they are searching for.
\item Maintainers: The hierarchical structure of the module guide improves the
  maintainers' understanding when they need to make changes to the system. It is
  important for a maintainer to update the relevant sections of the document
  after changes have been made.
\item Designers: Once the module guide has been written, it can be used to
  check for consistency, feasibility, and flexibility. Designers can verify the
  system in various ways, such as consistency among modules, feasibility of the
  decomposition, and flexibility of the design.
\end{itemize}

The rest of the document is organized as follows. Section
\ref{SecChange} lists the anticipated and unlikely changes of the software
requirements. Section \ref{SecMH} summarizes the module decomposition that
was constructed according to the likely changes. Section \ref{SecConnection}
specifies the connections between the software requirements and the
modules. Section \ref{SecMD} gives a detailed description of the
modules. Section \ref{SecTM} includes two traceability matrices. One checks
the completeness of the design against the requirements provided in the SRS. The
other shows the relation between anticipated changes and the modules. Section
\ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system. According to the likeliness
of the change, the possible changes are classified into two
categories. Anticipated changes are listed in Section \ref{SecAchange}, and
unlikely changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. The approach
adapted here is called design for
change.

\begin{description}
\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific
  hardware on which the software is running.
\item[\refstepcounter{acnum} \actheacnum \label{acInput}:] The format of the
  initial input data.
\item ...
\end{description}

\wss{Anticipated changes relate to changes that would be made in requirements,
design or implementation choices.  They are not related to changes that are made
at run-time, like the values of parameters.}

\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible. However, a general system is
more complex. Sometimes this complexity is not necessary. Fixing some design
decisions at the system architecture stage can simplify the software design. If
these decision should later need to be changed, then many parts of the design
will potentially need to be modified. Hence, it is not intended that these
decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum \label{ucIO}:] Input/Output devices
  (Input: File and/or Keyboard, Output: File, Memory, and/or Screen).
\item ...
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the modular design for Hitchly.  
The hierarchy follows the principle of information hiding, where each module  
encapsulates a design decision that may change independently.  
Only the leaf modules shown in Table~\ref{TblMH} are implemented.

\begin{description}

\item[\textbf{5.1 Hardware-Hiding Modules}]  
There are no hardware-hiding modules in this design.  
Hitchly relies on high-level framework APIs (Expo, React Native),  
so no direct hardware abstraction is required.

\item[\textbf{5.2 Behaviour-Hiding Modules}]  
These modules implement the user-visible behaviour of the application.  
They hide workflow logic, API interactions, and data handling that support  
Hitchly’s core features.

\begin{itemize}
  \item M1: Authentication \& Verification Module
  \item M2: User Profile Module
  \item M3: Route \& Trip Module
  \item M4: Matching Module
  \item M5: Scheduling Module
  \item M6: Notification Module
  \item M7: Rating \& Feedback Module
  \item M8: Safety \& Reporting Module
  \item M9: Payment \& Cost Estimation Module
  \item M10: Admin \& Moderation Module
\end{itemize}

\item[\textbf{5.3 Software-Decision Modules}]  
These modules encapsulate internal logic, algorithms,  
and implementation decisions not visible to users.

\begin{itemize}
  \item M11: Pricing Module
  \item M12: Database Module
\end{itemize}

\end{description}

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule
Hardware-Hiding Module & None\\
\midrule
\multirow{10}{0.3\textwidth}{Behaviour-Hiding Module}
& M1: Authentication \& Verification Module\\
& M2: User Profile Module\\
& M3: Route \& Trip Module\\
& M4: Matching Module\\
& M5: Scheduling Module\\
& M6: Notification Module\\
& M7: Rating \& Feedback Module\\
& M8: Safety \& Reporting Module\\
& M9: Payment \& Cost Estimation Module\\
& M10: Admin \& Moderation Module\\
\midrule
\multirow{2}{0.3\textwidth}{Software-Decision Module}
& M11: Pricing Module\\
& M12: Database Module\\
\bottomrule
\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}



\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in
the SRS. In this stage, the system is decomposed into modules. The connection
between requirements and modules is listed in Table~\ref{TblRT}.

\section{Module Decomposition} \label{SecMD}

\begingroup
\setlength{\parindent}{0pt}

Modules are decomposed according to the principle of information hiding
\citep{ParnasEtAl1984}.  
Each module’s \textit{Secrets} describes the internal design decision that is
intentionally hidden from other modules, while the \textit{Services} field specifies
\textit{what} the module provides without revealing \textit{how} the service is implemented.  
The \textit{Frontend UI}, \textit{API Logic}, and \textit{Database Models} indicate 
how each module is realized across the system’s architecture.  
\textit{Implemented By} identifies the technologies used, and 
\textit{Type of Module} classifies each module as a Behaviour-Hiding or 
Software-Decision module according to Section~\ref{SecMH}.  
Only the leaf modules are included.

% ---------------------------------------------------------
% BEHAVIOUR-HIDING MODULES
% ---------------------------------------------------------
\subsection*{Behaviour-Hiding Modules}

\subsubsection*{M1: Authentication \& Verification Module}
\begin{itemize}
  \item \textbf{Secrets:} Token/session strategy, email-verification workflow, and credential-validation logic.
  \item \textbf{Services:} Allows users to register, log in, and verify McMaster email accounts.
  \item \textbf{Frontend UI:} Login screens, signup forms, verification code UI.
  \item \textbf{API Logic:} \texttt{authRouter} (login, register, verify), session helpers, Zod validation.
  \item \textbf{Database Models:} \texttt{User} table (email, password hash, verified flag, session tokens).
  \item \textbf{Implemented By:} React Native (Expo) + tRPC backend with Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M2: User Profile Module}
\begin{itemize}
  \item \textbf{Secrets:} Role-assignment logic and profile-preference storage design.
  \item \textbf{Services:} Provides profile editing, preferences, and vehicle data management.
  \item \textbf{Frontend UI:} Profile page, edit forms, vehicle info inputs.
  \item \textbf{API Logic:} \texttt{userRouter} for CRUD operations, preference update flow.
  \item \textbf{Database Models:} \texttt{User}, \texttt{Vehicle}, \texttt{Preference}.
  \item \textbf{Implemented By:} React Native UI + tRPC + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M3: Route \& Trip Module}
\begin{itemize}
  \item \textbf{Secrets:} Trip-storage schema, route normalization, and time formatting.
  \item \textbf{Services:} Allows users to create, list, and cancel trips.
  \item \textbf{Frontend UI:} Trip creation form, trip list UI, route selection screen.
  \item \textbf{API Logic:} \texttt{tripRouter} for trip creation, querying, and deletion.
  \item \textbf{Database Models:} \texttt{Trip} table (origin, destination, time, seat count).
  \item \textbf{Implemented By:} React Native + tRPC backend + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M4: Matching Module}
\begin{itemize}
  \item \textbf{Secrets:} Scoring algorithm, distance/time weighting, and Strategy Pattern implementation.
  \item \textbf{Services:} Computes driver–rider compatibility and returns ordered match results.
  \item \textbf{Frontend UI:} Swipe-based card UI, match results list.
  \item \textbf{API Logic:} \texttt{matchmakingRouter}, MatchEngine (Strategy Pattern).
  \item \textbf{Database Models:} \texttt{Match}, \texttt{Swipe}.
  \item \textbf{Implemented By:} Node.js backend (tRPC) + algorithm utilities + Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M5: Scheduling Module}
\begin{itemize}
  \item \textbf{Secrets:} Recurring-trip generation algorithm and time-window parsing.
  \item \textbf{Services:} Creates recurring or one-time schedules linked to trips.
  \item \textbf{Frontend UI:} Time picker, recurring toggle, calendar UI.
  \item \textbf{API Logic:} Schedule parser and recurring schedule generator.
  \item \textbf{Database Models:} \texttt{Schedule} table.
  \item \textbf{Implemented By:} tRPC backend + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M6: Notification Module}
\begin{itemize}
  \item \textbf{Secrets:} Push-token handling and asynchronous event queue logic.
  \item \textbf{Services:} Sends push notifications for matches, cancellations, and reminders.
  \item \textbf{Frontend UI:} In-app notification center, Expo push integration.
  \item \textbf{API Logic:} Notification service with event emitters.
  \item \textbf{Database Models:} \texttt{Notification} table.
  \item \textbf{Implemented By:} Expo Push Service + tRPC backend dispatcher.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M7: Rating \& Feedback Module}
\begin{itemize}
  \item \textbf{Secrets:} Reputation computation and weighting logic.
  \item \textbf{Services:} Enables users to submit ratings and text feedback after trips.
  \item \textbf{Frontend UI:} Post-ride rating screen.
  \item \textbf{API Logic:} \texttt{ratingRouter}.
  \item \textbf{Database Models:} \texttt{Rating} table (linked to \texttt{Match}).
  \item \textbf{Implemented By:} React Native + tRPC + Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M8: Safety \& Reporting Module}
\begin{itemize}
  \item \textbf{Secrets:} Incident-flagging thresholds and safety-response workflow.
  \item \textbf{Services:} Allows reporting of unsafe behaviour and stores incidents for admin review.
  \item \textbf{Frontend UI:} Report button, safety resources screen.
  \item \textbf{API Logic:} Report submission via \texttt{reportRouter}.
  \item \textbf{Database Models:} \texttt{Report}.
  \item \textbf{Implemented By:} React Native + tRPC + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M9: Payment \& Cost Estimation Module}
\begin{itemize}
  \item \textbf{Secrets:} Fare-calculation logic and mock-payment validation.
  \item \textbf{Services:} Estimates ride cost and records payment confirmations.
  \item \textbf{Frontend UI:} Fare display, confirmation screen.
  \item \textbf{API Logic:} \texttt{paymentRouter}.
  \item \textbf{Database Models:} \texttt{Payment}, \texttt{Transaction}.
  \item \textbf{Implemented By:} tRPC backend + Prisma ORM.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

\subsubsection*{M10: Admin \& Moderation Module}
\begin{itemize}
  \item \textbf{Secrets:} Moderation rules, flagging thresholds, and admin-only access logic.
  \item \textbf{Services:} Allows admins to review reports, ban users, and view platform stats.
  \item \textbf{Frontend UI:} Admin dashboard (optional).
  \item \textbf{API Logic:} \texttt{adminRouter}.
  \item \textbf{Database Models:} Admin logs, flagged users.
  \item \textbf{Implemented By:} tRPC backend + Prisma.
  \item \textbf{Type of Module:} Behaviour-Hiding Module.
\end{itemize}

% ---------------------------------------------------------
% SOFTWARE-DECISION MODULES
% ---------------------------------------------------------
\subsection*{Software-Decision Modules}

\subsubsection*{M11: Pricing Module}
\begin{itemize}
  \item \textbf{Secrets:} Fuel-rate constants, distance multipliers, and fare model.
  \item \textbf{Services:} Computes estimated trip price using distance and conditions.
  \item \textbf{Frontend UI:} Fare estimate displayed in trip preview.
  \item \textbf{API Logic:} Cost-calculation service reused by M9.
  \item \textbf{Database Models:} Pricing configuration constants.
  \item \textbf{Implemented By:} Node.js backend utilities + shared pricing helpers.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\subsubsection*{M12: Database Module}
\begin{itemize}
  \item \textbf{Secrets:} ORM mapping, schema decisions, and migration strategy.
  \item \textbf{Services:} Provides access to all persistent data models via a centralized DB client.
  \item \textbf{Frontend UI:} None.
  \item \textbf{API Logic:} Prisma client configuration and model exports.
  \item \textbf{Database Models:} All tables (User, Trip, Match, Schedule, etc.).
  \item \textbf{Implemented By:} Prisma ORM + PostgreSQL.
  \item \textbf{Type of Module:} Software-Decision Module.
\end{itemize}

\endgroup


\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

% the table should use mref, the requirements should be named, use something
% like fref
\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Req.} & \textbf{Modules}\\
\midrule
FR211 & M4, M3, M5, M10\\
FR212 & M4, M5, M10\\
FR213 & M4, M2\\
FR214 & M4, M2, M5\\
NFR211 & M4, M10\\
NFR212 & M4, M1, M10\\
FR221 & M5, M3, M10\\
FR222 & M5, M6\\
FR223 & M5, M6, M9\\
FR224 & M6, M5\\
NFR221 & M10, M5\\
NFR222 & M6, M5, M10\\
FR231 & M1, M2\\
FR232 & M1, M10\\
FR233 & M8, M3, M6\\
FR234 & M8, M2, M12\\
NFR231 & M1, M10\\
NFR232 & M1, M10, M12\\
FR241 & M11, M5, M3\\
FR242 & M9\\
FR243 & M9\\
FR244 & M10, M9\\
NFR241 & M9\\
NFR242 & M9\\
FR251 & M2, M1\\
FR252 & M10, M2\\
FR253 & M10, M2, M3\\
FR254 & M2, M4\\
NFR251 & M2, M1\\
NFR252 & M2, M10\\
FR261 & M7, M2\\
FR262 & M8, M12\\
FR263 & M7, M5, M4\\
FR264 & M7, M2\\
NFR261 & M7, M12\\



\bottomrule
\end{tabular}
\caption{Trace Between Requirements and Modules}
\label{TblRT}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{AC} & \textbf{Modules}\\
\midrule
\acref{acMatchingAlgorithm} & M4, M2, M5\\
\acref{acUserInterface} & M1, M2, M3, M4, M5, M6, M7, M8, M9, M11, M12\\
\acref{acDB} & M10\\
\acref{acPayment} & M9, M11\\
\acref{acDevEnvioremnt} & N/A (External Process)\\
\bottomrule
\end{tabular}
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is
provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if
correct execution of B may be necessary for A to complete the task described in
its specification. That is, A {\em uses} B if there exist situations in which
the correct functioning of A depends upon the availability of a correct
implementation of B.  Figure \ref{FigUH} illustrates the use relation between
the modules. It can be seen that the graph is a directed acyclic graph
(DAG). Each level of the hierarchy offers a testable and usable subset of the
system, and modules in the higher level of the hierarchy are essentially simpler
because they use modules from the lower levels.

\wss{The uses relation is not a data flow diagram.  In the code there will often
be an import statement in module A when it directly uses module B.  Module B
provides the services that module A needs.  The code for module A needs to be
able to see these services (hence the import statement).  Since the uses
relation is transitive, there is a use relation without an import, but the
arrows in the diagram typically correspond to the presence of import statement.}

\wss{If module A uses module B, the arrow is directed from A to B.}

\begin{figure}[H]
\centering
%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
\caption{Use hierarchy among modules}
\label{FigUH}
\end{figure}

%\section*{References}

\section{User Interfaces}

\wss{Design of user interface for software and hardware.  Attach an appendix if
needed. Drawings, Sketches, Figma}

\section{Design of Communication Protocols}

This section describes the design of the communication protocols implemented in Hitchly.
Communication occurs primarily between the client‐side mobile application (developed
with React Native / Expo) and the backend server (implemented with Node.js, Express,
and tRPC).  The system also integrates third-party APIs for geolocation and notifications.

\subsection{11.1 Overall Architecture}

All communication between the mobile client and the backend follows a request–response
model over HTTPS, ensuring confidentiality and integrity.  Data is serialized in JSON
format and transferred through REST and type-safe tRPC endpoints.  The architecture
adopts a modular service-based design to support scalability and maintainability:

\begin{itemize}
  \item \textbf{Frontend (Client):} React Native app that sends authenticated requests
  to backend endpoints via HTTPS using the tRPC client.
  \item \textbf{Backend (Server):} Express server exposing routes through the tRPC API layer.
  It validates and processes incoming requests, interacts with the PostgreSQL database
  through Drizzle ORM, and returns structured JSON responses.
  \item \textbf{External Services:} Mapping and geolocation (Google Maps / Mapbox API),
  Expo Push Notification Service for alerts, and optional OAuth verification via McMaster
  SSO (for email validation).
\end{itemize}

\subsection{11.2 Communication Flow}

A typical data exchange involves the following sequence:

\begin{enumerate}
  \item The user performs an action in the mobile application (e.g., requests a ride,
  updates schedule, or rates a driver).
  \item The frontend constructs a tRPC call encapsulating the action data and attaches
  the user’s JWT authentication token in the header.
  \item The server authenticates the request, validates input schemas, and executes the
  corresponding service logic.
  \item The backend queries or updates PostgreSQL through Drizzle ORM and returns a
  success or error payload to the client.
  \item The client updates its UI state using React Query based on the received data.
\end{enumerate}

\subsection{11.3 API Endpoints and Message Types}

Hitchly’s backend exposes the following logical API groups:

\begin{itemize}
  \item \textbf{Auth API:} Handles user registration, login, McMaster email verification,
  and token refresh.  Exchanges encrypted credentials and JWT tokens.
  \item \textbf{User API:} Manages user profiles, schedules, and preferences.
  \item \textbf{Matching API:} Accepts commute data, performs matching algorithm, and
  returns ranked ride offers.
  \item \textbf{Trip API:} Records completed trips, generates summaries, and calculates
  cost-sharing.
  \item \textbf{Rating API:} Sends and retrieves ratings and reviews.
  \item \textbf{Notification API:} Uses Expo Push Notification service to deliver trip
  confirmations, cancellations, and updates in real time.
\end{itemize}

All messages follow the JSON structure:
\begin{verbatim}
{
  "status": "success",
  "data": { ... },
  "timestamp": "2025-01-03T12:00:00Z"
}
\end{verbatim}

\subsection{11.4 Security and Reliability}

Security and reliability are ensured through:

\begin{itemize}
  \item \textbf{Transport Security:} HTTPS with TLS 1.3 and HSTS enforcement.
  \item \textbf{Authentication:} JWT Bearer tokens included in headers of all authorized
  requests.
  \item \textbf{Input Validation:} All incoming payloads validated using Zod schemas in
  tRPC to prevent injection or malformed data.
  \item \textbf{Error Handling:} Standardized error codes with human-readable messages
  returned to the client.
  \item \textbf{Rate Limiting:} Express middleware limits excessive requests to prevent
  abuse.
  \item \textbf{Retry Mechanism:} Client-side React Query retries transient network
  failures automatically.
\end{itemize}

\subsection{11.5 Design Considerations}

The communication design of Hitchly emphasizes the following principles:

\begin{itemize}
  \item \textbf{Consistency:} Shared TypeScript types across frontend and backend
  guarantee end-to-end type safety through tRPC.
  \item \textbf{Extensibility:} Additional endpoints (e.g., payment API or advanced analytics)
  can be introduced without modifying existing client modules.
  \item \textbf{Scalability:} The stateless REST/tRPC design supports horizontal scaling
  of the Express server behind a load balancer.
  \item \textbf{Low Latency:} JSON over HTTPS is lightweight; caching of common responses
  and asynchronous notification delivery minimize perceived delay.
\end{itemize}

This design ensures secure, efficient, and maintainable communication between Hitchly’s
mobile application, backend, and external services, supporting its goals of safety,
reliability, and sustainability for McMaster commuters.


\section{Timeline}

\wss{Schedule of tasks and who is responsible}

\wss{You can point to GitHub if this information is included there}

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage{}

\end{document}